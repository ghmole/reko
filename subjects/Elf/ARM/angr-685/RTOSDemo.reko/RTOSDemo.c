// RTOSDemo.c
// Generated by decompiling RTOSDemo.axf
// using Reko decompiler version 0.9.0.0.

#include "RTOSDemo.h"

// 00000058: void prvUnlockQueue(Register Eq_n r0, Register ptr32 cpsr)
void prvUnlockQueue(Eq_n r0, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	int32 r4_n = (int32) (int8) (word32) *((word32) r0 + 0x0045);
	if (r4_n > 0x00 && *((word32) r0 + 0x0024) != 0x00)
	{
		do
		{
			if (xTaskRemoveFromEventList((word32) r0 + 0x0024) != 0x00)
			{
				vTaskMissedYield();
				uint32 r3_n = (uint32) (byte) (r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
			else
			{
				uint32 r3_n = (uint32) (byte) (r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
		} while (*((word32) r0 + 0x0024) != 0x00);
	}
	((word32) r0 + 0x0045)->u0 = ~0x00;
	vPortExitCritical(cpsr);
	vPortEnterCritical(cpsr);
	int32 r4_n = (int32) (int8) (word32) *((word32) r0 + 0x0044);
	if (r4_n > 0x00 && *((word32) r0 + 0x0010) != 0x00)
	{
		do
		{
			if (xTaskRemoveFromEventList((word32) r0 + 0x0010) != 0x00)
			{
				vTaskMissedYield();
				uint32 r3_n = (uint32) (byte) (r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
			else
			{
				uint32 r3_n = (uint32) (byte) (r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
		} while (*((word32) r0 + 0x0010) != 0x00);
	}
	((word32) r0 + 0x0044)->u0 = ~0x00;
	vPortExitCritical(cpsr);
}

// 000000EC: FlagGroup bool prvCopyDataToQueue(Register Eq_n r0, Register Eq_n r1, Register Eq_n r2, Register Eq_n r7, Register Eq_n lr, Register out Eq_n r0Out, Register out Eq_n r7Out, Register out Eq_n lrOut)
bool prvCopyDataToQueue(Eq_n r0, Eq_n r1, Eq_n r2, Eq_n r7, Eq_n lr, union Eq_n & r0Out, union Eq_n & r7Out, union Eq_n & lrOut)
{
	bool Z_n;
	Eq_n r5_n;
	Eq_n r4_n = r0;
	Eq_n r0_n = *((word32) r0 + 0x0040);
	Eq_n r5_n = *((word32) r0 + 0x0038);
	if (r0_n == 0x00)
	{
		Eq_n r6_n = *r0;
		if (r6_n != 0x00)
		{
			r5_n = (word32) r5_n + 0x01;
			Z_n = SLICE(cond((word32) r5_n + 0x01), bool, 2);
		}
		else
		{
			r0_n = xTaskPriorityDisinherit(*((word32) r0 + 0x04), out lr);
			*((word32) r0 + 0x04) = r6_n;
			r5_n = (word32) r5_n + 0x01;
			Z_n = SLICE(cond((word32) r5_n + 0x01), bool, 2);
		}
	}
	else
	{
		if (r2 == 0x00)
		{
			Eq_n lr_n;
			struct Eq_n * r4_n;
			word32 r5_n;
			Eq_n r6_n;
			Eq_n r7_n;
			memcpy(*((word32) r0 + 0x08), r1, r0_n, r0, r5_n, r2, r7, lr, out r4_n, out r5_n, out r6_n, out r7_n, out lr_n);
			up32 r2_n = r4_n->dw0004;
			up32 r3_n = r4_n->dw0008 + r4_n->dw0040;
			r4_n->dw0008 = r3_n;
			if (r3_n < r2_n)
			{
				r4_n->dw0038 = r5_n + 0x01;
				r0Out = r6_n;
				r7Out = r7_n;
				lrOut = lr_n;
				return SLICE(cond(r5_n + 0x01), bool, 2);
			}
			else
			{
				r4_n->dw0008 = r4_n->dw0000;
				r4_n->dw0038 = r5_n + 0x01;
				r0Out = r6_n;
				r7Out = r7_n;
				lrOut = lr_n;
				return SLICE(cond(r5_n + 0x01), bool, 2);
			}
		}
		word32 r6_n;
		memcpy(*((word32) r0 + 0x0C), r1, r0_n, r0, r5_n, r2, r7, lr, out r4_n, out r5_n, out r6_n, out r7, out lr);
		Eq_n r3_n = *((word32) r4_n + 0x0C);
		Eq_n r1_n = *r4_n;
		*((word32) r4_n + 0x0C) = r3_n;
		if (r3_n < r1_n)
			*((word32) r4_n + 0x0C) = *((word32) r4_n + 0x04);
		Z_n = SLICE(cond(r6_n - 0x02), bool, 2);
		if (r6_n != 0x02)
		{
			*((word32) r4_n + 0x0038) = (word32) r5_n + 0x01;
			r0Out.u0 = 0x00;
			r7Out = r7;
			lrOut = lr;
			return SLICE(cond((word32) r5_n + 0x01), bool, 2);
		}
		if (r5_n == 0x00)
			r5_n.u0 = 0x01;
		r0_n.u0 = 0x00;
	}
	*((word32) r4_n + 0x0038) = r5_n;
	r0Out = r0_n;
	r7Out = r7;
	lrOut = lr;
	return Z_n;
}

// 0000016C: Register Eq_n prvCopyDataFromQueue(Register Eq_n r0, Register Eq_n r1, Register Eq_n r4, Register Eq_n r5, Register Eq_n r6, Register Eq_n r7, Register Eq_n lr, Register out Eq_n r5Out, Register out Eq_n r6Out, Register out Eq_n r7Out, Register out Eq_n lrOut)
Eq_n prvCopyDataFromQueue(Eq_n r0, Eq_n r1, Eq_n r4, Eq_n r5, Eq_n r6, Eq_n r7, Eq_n lr, union Eq_n & r5Out, union Eq_n & r6Out, union Eq_n & r7Out, union Eq_n & lrOut)
{
	Eq_n r2_n = *((word32) r0 + 0x0040);
	if (r2_n == 0x00)
	{
		r5Out = r5;
		r6Out = r6;
		r7Out = r7;
		lrOut = lr;
		return r4;
	}
	else
	{
		Eq_n r4_n = *((word32) r0 + 0x04);
		word32 r1_n = Mem10[r0 + 0x0C:word32] + r2_n;
		*((word32) r0 + 0x0C) = r1_n;
		if (r1_n >= r4_n)
			r1_n = *r0;
		*((word32) r0 + 0x0C) = r1_n;
		Eq_n lr_n;
		Eq_n r4_n;
		Eq_n r5_n;
		Eq_n r6_n;
		Eq_n r7_n;
		memcpy(r1, r1_n, r2_n, r4, r5, r6, r7, lr, out r4_n, out r5_n, out r6_n, out r7_n, out lr_n);
		r5Out = r5_n;
		r6Out = r6_n;
		r7Out = r7_n;
		lrOut = lr_n;
		return r4_n;
	}
}

// 00000190: Register Eq_n xQueueGenericSend(Register Eq_n r0, Register Eq_n r1, Register up32 r2, Register Eq_n r3, Register Eq_n lr, Register ptr32 cpsr)
Eq_n xQueueGenericSend(Eq_n r0, Eq_n r1, up32 r2, Eq_n r3, Eq_n lr, ptr32 cpsr)
{
	word32 r5_n = 0x00;
	word32 * r9_n = globals->ptr02A0;
	while (true)
	{
		vPortEnterCritical(cpsr);
		if (*((word32) r0 + 0x0038) < *((word32) r0 + 0x003C) || r3 == 0x02)
			break;
		if (r2 == 0x00)
		{
			vPortExitCritical(cpsr);
			return lr;
		}
		if (r5_n == 0x00)
			vTaskSetTimeOutState(fp - 0x0028);
		vPortExitCritical(cpsr);
		vTaskSuspendAll();
		vPortEnterCritical(cpsr);
		if ((word32) *((word32) r0 + 0x0044) == 0xFF)
			((word32) r0 + 0x0044)->u0 = 0x00;
		if ((word32) *((word32) r0 + 0x0045) == 0xFF)
			((word32) r0 + 0x0045)->u0 = 0x00;
		vPortExitCritical(cpsr);
		if (xTaskCheckForTimeOut(fp - 0x0028, fp - 44, cpsr) != 0x00)
		{
			prvUnlockQueue(r0, cpsr);
			xTaskResumeAll(cpsr);
			return lr;
		}
		vPortEnterCritical(cpsr);
		if (*((word32) r0 + 0x0038) != *((word32) r0 + 0x003C))
		{
			vPortExitCritical(cpsr);
			prvUnlockQueue(r0, cpsr);
			xTaskResumeAll(cpsr);
		}
		else
		{
			vPortExitCritical(cpsr);
			vTaskPlaceOnEventList((word32) r0 + 0x0010, r2);
			prvUnlockQueue(r0, cpsr);
			if (xTaskResumeAll(cpsr) == 0x00)
			{
				*r9_n = 0x10000000;
				__dsb_sy();
				__isb_sy();
			}
		}
		r5_n = 0x01;
	}
	Eq_n lr_n;
	word32 r0_n;
	word32 r7_n;
	prvCopyDataToQueue(r0, r1, r3, r3, lr, out r0_n, out r7_n, out lr_n);
	if (*((word32) r0 + 0x0024) == 0x00)
	{
		if (r0_n == 0x00)
			goto l00000266;
	}
	else if (xTaskRemoveFromEventList((word32) r0 + 0x0024) == 0x00)
		goto l00000266;
	*globals->ptr02A0 = 0x10000000;
	__dsb_sy();
	__isb_sy();
l00000266:
	vPortExitCritical(cpsr);
	return lr_n;
}

// 000002A4: void xQueuePeekFromISR(Register Eq_n r0, Register Eq_n r1, Register Eq_n r7, Register Eq_n lr, Register ptr32 cpsr)
void xQueuePeekFromISR(Eq_n r0, Eq_n r1, Eq_n r7, Eq_n lr, ptr32 cpsr)
{
	Eq_n r5_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (*((word32) r0 + 0x0038) != 0x00)
	{
		Eq_n r5_n;
		word32 r6_n;
		word32 r7_n;
		word32 lr_n;
		prvCopyDataFromQueue(r0, r1, r0, r5_n, *((word32) r0 + 0x0C), r7, lr, out r5_n, out r6_n, out r7_n, out lr_n)->dw000C = r6_n;
		__msr(cpsr, r5_n);
	}
	else
		__msr(cpsr, r5_n);
}

// 000002D8: Register Eq_n xQueueGenericReceive(Register Eq_n r0, Register Eq_n r1, Register up32 r2, Register word32 r3, Register Eq_n lr, Register ptr32 cpsr, Register out Eq_n lrOut)
Eq_n xQueueGenericReceive(Eq_n r0, Eq_n r1, up32 r2, word32 r3, Eq_n lr, ptr32 cpsr, union Eq_n & lrOut)
{
	word32 r5_n = 0x00;
	word32 * r8_n = globals->ptr0424;
	while (true)
	{
		vPortEnterCritical(cpsr);
		Eq_n r6_n = *((word32) r0 + 0x0038);
		if (r6_n != 0x00)
			break;
		if (r2 == 0x00)
		{
l000003A4:
			vPortExitCritical(cpsr);
			lrOut = lr;
			return 0x00;
		}
		if (r5_n == 0x00)
			vTaskSetTimeOutState(fp - 0x0028);
		vPortExitCritical(cpsr);
		vTaskSuspendAll();
		vPortEnterCritical(cpsr);
		if ((word32) *((word32) r0 + 0x0044) == 0xFF)
			((word32) r0 + 0x0044)->u0 = 0x00;
		if ((word32) *((word32) r0 + 0x0045) == 0xFF)
			((word32) r0 + 0x0045)->u0 = 0x00;
		vPortExitCritical(cpsr);
		if (xTaskCheckForTimeOut(fp - 0x0028, fp - 44, cpsr) != 0x00)
		{
			prvUnlockQueue(r0, cpsr);
			xTaskResumeAll(cpsr);
			vPortEnterCritical(cpsr);
			if (*((word32) r0 + 0x0038) == 0x00)
				goto l000003A4;
			vPortExitCritical(cpsr);
		}
		else
		{
			vPortEnterCritical(cpsr);
			if (*((word32) r0 + 0x0038) != 0x00)
			{
				vPortExitCritical(cpsr);
				prvUnlockQueue(r0, cpsr);
				xTaskResumeAll(cpsr);
			}
			else
			{
				vPortExitCritical(cpsr);
				if (*r0 == 0x00)
				{
					vPortEnterCritical(cpsr);
					vTaskPriorityInherit(*((word32) r0 + 0x04));
					vPortExitCritical(cpsr);
				}
				vTaskPlaceOnEventList((word32) r0 + 0x0024, r2);
				prvUnlockQueue(r0, cpsr);
				if (xTaskResumeAll(cpsr) == 0x00)
				{
					*r8_n = 0x10000000;
					__dsb_sy();
					__isb_sy();
				}
			}
		}
		r5_n = 0x01;
	}
	Eq_n lr_n;
	word32 r5_n;
	word32 r6_n;
	word32 r7_n;
	struct Eq_n * r4_n = prvCopyDataFromQueue(r0, r1, r0, *((word32) r0 + 0x0C), r6_n, 0x00, lr, out r5_n, out r6_n, out r7_n, out lr_n);
	if (r3 == 0x00)
	{
		word32 r3_n = r4_n->dw0000;
		r4_n->dw0038 = r6_n - 0x01;
		if (r3_n == 0x00)
			r4_n->dw0004 = pvTaskIncrementMutexHeldCount();
		if (r4_n->dw0010 == 0x00 || xTaskRemoveFromEventList(&r4_n->dw0010) == 0x00)
		{
l000003CC:
			vPortExitCritical(cpsr);
			lrOut = lr_n;
			return 0x01;
		}
	}
	else
	{
		word32 r3_n = r4_n->dw0024;
		r4_n->dw000C = r5_n;
		if (r3_n == 0x00 || xTaskRemoveFromEventList(&r4_n->dw0024) == 0x00)
			goto l000003CC;
	}
	*globals->ptr0424 = 0x10000000;
	__dsb_sy();
	__isb_sy();
	goto l000003CC;
}

// 00000428: void uxQueueMessagesWaiting(Register ptr32 cpsr)
void uxQueueMessagesWaiting(ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	vPortExitCritical(cpsr);
}

// 0000043C: void uxQueueSpacesAvailable(Register ptr32 cpsr)
void uxQueueSpacesAvailable(ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	vPortExitCritical(cpsr);
}

// 00000454: void vQueueDelete()
void vQueueDelete()
{
	vPortFree();
}

// 00000458: void xQueueGenericSendFromISR(Register Eq_n r0, Register Eq_n r1, Register Eq_n r2, Register Eq_n r3, Register Eq_n lr, Register ptr32 cpsr)
void xQueueGenericSendFromISR(Eq_n r0, Eq_n r1, Eq_n r2, Eq_n r3, Eq_n lr, ptr32 cpsr)
{
	Eq_n r6_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (*((word32) r0 + 0x0038) < *((word32) r0 + 0x003C) || r3 == 0x02)
	{
		int32 r4_n = (int32) (int8) (word32) *((word32) r0 + 0x0045);
		word32 r0_n;
		word32 lr_n;
		word32 * r7_n;
		if (!prvCopyDataToQueue(r0, r1, r3, r2, lr, out r0_n, out r7_n, out lr_n))
			((word32) r0 + 0x0045)->u0 = (byte) (int32) (int8) (r4_n + 0x01);
		else if (*((word32) r0 + 0x0024) != 0x00 && (xTaskRemoveFromEventList((word32) r0 + 0x0024) != 0x00 && r7_n != null))
		{
			*r7_n = 0x01;
			goto l0000047C;
		}
		__msr(cpsr, r6_n);
	}
	else
	{
l0000047C:
		__msr(cpsr, r6_n);
	}
}

// 000004C4: void xQueueGiveFromISR(Register (ptr32 Eq_n) r0, Register (ptr32 word32) r1, Register ptr32 cpsr)
void xQueueGiveFromISR(struct Eq_n * r0, word32 * r1, ptr32 cpsr)
{
	Eq_n r4_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	up32 r2_n = r0->dw0038;
	if (r2_n >= r0->dw003C)
	{
		__msr(cpsr, r4_n);
		return;
	}
	int32 r3_n = (int32) (int8) (word32) r0->b0045;
	r0->dw0038 = r2_n + 0x01;
	if (r2_n != 0x01)
		r0->b0045 = (byte) (int32) (int8) (r3_n + 0x01);
	else if (r0->dw0024 != 0x00 && (xTaskRemoveFromEventList(&r0->dw0024) != 0x00 && r1 != null))
	{
		*r1 = 0x01;
l000004FA:
		__msr(cpsr, r4_n);
		return;
	}
	goto l000004FA;
}

// 00000524: void xQueueReceiveFromISR(Register Eq_n r0, Register Eq_n r1, Register (ptr32 word32) r2, Register Eq_n lr, Register ptr32 cpsr)
void xQueueReceiveFromISR(Eq_n r0, Eq_n r1, word32 * r2, Eq_n lr, ptr32 cpsr)
{
	Eq_n r6_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	Eq_n r4_n = *((word32) r0 + 0x0038);
	if (r4_n != 0x00)
	{
		word32 lr_n;
		word32 r5_n;
		struct Eq_n * r7_n;
		struct Eq_n * r4_n = prvCopyDataFromQueue(r0, r1, r4_n, (int32) (int8) (word32) *((word32) r0 + 0x0044), r6_n, r0, lr, out r5_n, out r6_n, out r7_n, out lr_n);
		r7_n->dw0038 = r4_n - &globals->dw0001;
		if (r4_n != &globals->dw0001)
			r7_n->b0044 = (byte) (int32) (int8) (r5_n + 0x01);
		else if (r7_n->dw0010 != 0x00 && (xTaskRemoveFromEventList(&r7_n->dw0010) != 0x00 && r2 != null))
		{
			*r2 = 0x01;
			goto l00000542;
		}
		__msr(cpsr, r6_n);
	}
	else
	{
l00000542:
		__msr(cpsr, r6_n);
	}
}

// 00000594: void xQueueIsQueueEmptyFromISR(Register (ptr32 Eq_n) r0)
void xQueueIsQueueEmptyFromISR(struct Eq_n * r0)
{
	__clz(r0->dw0038);
}

// 000005A0: void xQueueIsQueueFullFromISR(Register (ptr32 Eq_n) r0)
void xQueueIsQueueFullFromISR(struct Eq_n * r0)
{
	__clz(r0->dw003C - r0->dw0038);
}

// 000005B0: void uxQueueMessagesWaitingFromISR()
void uxQueueMessagesWaitingFromISR()
{
}

// 000005B4: void xQueueGetMutexHolder(Register (ptr32 word32) r0, Register ptr32 cpsr)
void xQueueGetMutexHolder(word32 * r0, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	if (*r0 != 0x00)
		vPortExitCritical(cpsr);
	else
		vPortExitCritical(cpsr);
}

// 000005D4: void xQueueTakeMutexRecursive(Register Eq_n r0, Register up32 r1, Register Eq_n lr, Register ptr32 cpsr)
void xQueueTakeMutexRecursive(Eq_n r0, up32 r1, Eq_n lr, ptr32 cpsr)
{
	if (*((word32) r0 + 0x04) == xTaskGetCurrentTaskHandle())
		*((word32) r0 + 0x0C) = (word32) *((word32) r0 + 0x0C) + 0x01;
	else
	{
		word32 lr_n;
		if (xQueueGenericReceive(r0, 0x00, r1, 0x00, lr, cpsr, out lr_n) != 0x00)
			*((word32) r0 + 0x0C) = (word32) *((word32) r0 + 0x0C) + 0x01;
	}
}

// 00000604: void xQueueGiveMutexRecursive(Register Eq_n r0, Register Eq_n lr, Register ptr32 cpsr)
void xQueueGiveMutexRecursive(Eq_n r0, Eq_n lr, ptr32 cpsr)
{
	if (*((word32) r0 + 0x04) != xTaskGetCurrentTaskHandle())
		return;
	Eq_n r3_n = *((word32) r0 + 0x0C);
	*((word32) r0 + 0x0C) = r3_n - 0x01;
	if (r3_n != 0x01)
		return;
	xQueueGenericSend(r0, r3_n - 0x01, r3_n - 0x01, r3_n - 0x01, lr, cpsr);
}

// 00000630: void xQueueGenericReset(Register (ptr32 Eq_n) r0, Register word32 r1, Register ptr32 cpsr)
void xQueueGenericReset(struct Eq_n * r0, word32 r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	ui32 r3_n = r0->dw0040;
	ui32 r2_n = r0->dw003C * r3_n;
	struct Eq_n * r0_n = r0->ptr0000;
	r0->dw0038 = 0x00;
	r0->dw0004 = r0_n + r2_n / 0x0066;
	r0->ptr0044 = &globals->tFFFFFFFF;
	r0->dw000C = r0_n + (r2_n - r3_n) / 0x0066;
	r0->ptr0008 = r0_n;
	r0->b0045 = ~0x00;
	if (r1 != 0x00)
	{
		vListInitialise(&r0->ptr0010);
		vListInitialise(&r0->ptr0024);
		vPortExitCritical(cpsr);
	}
	else if (r0->ptr0010 != null && xTaskRemoveFromEventList(&r0->ptr0010) != 0x00)
	{
		*globals->ptr06A8 = 0x10000000;
		__dsb_sy();
		__isb_sy();
		vPortExitCritical(cpsr);
	}
	else
		vPortExitCritical(cpsr);
}

// 000006AC: void xQueueGenericCreate(Register ui32 r0, Register ui32 r1, Register ptr32 cpsr)
void xQueueGenericCreate(ui32 r0, ui32 r1, ptr32 cpsr)
{
	struct Eq_n * r0_n = pvPortMalloc(r0 * r1 + 0x48, cpsr);
	if (r0_n != null)
	{
		if (r1 != 0x00)
			r0_n->ptr0000 = &r0_n->b0045 + 0x03;
		else
			r0_n->ptr0000 = r0_n;
		r0_n->dw003C = r0;
		r0_n->dw0040 = r1;
		xQueueGenericReset(r0_n, 0x01, cpsr);
	}
}

// 000006DC: void xQueueCreateMutex(Register Eq_n lr, Register ptr32 cpsr)
void xQueueCreateMutex(Eq_n lr, ptr32 cpsr)
{
	xQueueGenericCreate(0x01, 0x00, cpsr);
	if (0x01 != 0x00)
	{
		globals->dw0005 = 0x00;
		globals->dw0001 = 0x00;
		globals->dw000D = 0x00;
		xQueueGenericSend(0x01, 0x00, 0x00, 0x00, lr, cpsr);
	}
}

// 00000700: void prvInitialiseNewTask(Register ui32 r0, Register word32 r1, Register ui32 r2, Register word32 r3, Stack int32 dwArg00, Stack (ptr32 (ptr32 Eq_n)) dwArg04, Stack (ptr32 Eq_n) dwArg08, Stack (ptr32 Eq_n) dwArg0C)
void prvInitialiseNewTask(ui32 r0, word32 r1, ui32 r2, word32 r3, int32 dwArg00, struct Eq_n ** dwArg04, struct Eq_n * dwArg08, struct Eq_n * dwArg0C)
{
	byte * r3_n = r1 - 0x01 + 0x01;
	struct Eq_n * r5_n = dwArg08->ptr0050 + (r2 + 0x3FFFFFFF << 0x02) / 0x0066 & ~0x07;
	byte * r0_n = (char *) &dwArg08->ptr0050 + 0x04;
	uint32 r2_n = dwArg00 & ~0x80000000;
	do
	{
		*r0_n = (byte) (word32) *r3_n;
		++r3_n;
		++r0_n;
	} while ((word32) *r3_n != 0x00 && r3_n != r1 + 0x02);
	if (r2_n >= 0x01)
		r2_n = 0x01;
	dwArg08->dw004C = r2_n;
	dwArg08->dw0058 = r2_n;
	dwArg08->b0056 = 0x00;
	dwArg08->dw005C = 0x00;
	vListInitialiseItem(&dwArg08->ptr0024);
	vListInitialiseItem(&dwArg08->dw0038);
	dwArg08->dw0038 = 0x02 - r2_n;
	struct Eq_n * r2_n = dwArg08->ptr0050;
	dwArg08->ptr0030 = dwArg08;
	dwArg08->ptr0044 = dwArg08;
	vPortStoreTaskMPUSettings(&dwArg08->dw0004, dwArg0C, r2_n, r2);
	dwArg08->dw0060 = 0x00;
	dwArg08->b0064 = 0x00;
	dwArg08->ptr0000 = pxPortInitialiseStack(r5_n, r0, r3, dwArg00 >> 0x1F);
	if (dwArg04 != null)
		*dwArg04 = (struct Eq_n **) dwArg08;
}

// 00000798: void prvAddNewTaskToReadyList(Register (ptr32 Eq_n) r0, Register ptr32 cpsr)
void prvAddNewTaskToReadyList(struct Eq_n * r0, ptr32 cpsr)
{
	uint32 r0_n;
	struct Eq_n * r4_n = globals->ptr0854;
	vPortEnterCritical(cpsr);
	++r4_n->dw0000;
	if (r4_n->ptr0004 != null)
	{
		if (r4_n->dw0074 != 0x00)
		{
l000007B4:
			r0_n = r0->dw004C;
			goto l000007BA;
		}
		r0_n = r0->dw004C;
		if (r4_n->ptr0004->dw004C <= r0_n)
			r4_n->ptr0004 = r0;
	}
	else
	{
		r4_n->ptr0004 = r0;
		if (r4_n->dw0000 != 0x01)
			goto l000007B4;
		vListInitialise((char *) &r4_n->ptr0004 + 0x04);
		vListInitialise((char *) &r4_n->ptr0004 + 0x0018);
		vListInitialise((char *) &r4_n->ptr0004 + 44);
		vListInitialise((char *) &r4_n->ptr0004 + 0x0040);
		vListInitialise((char *) &r4_n->ptr0004 + 0x0054);
		r4_n->ptr006C = (char *) &r4_n->ptr0004 + 44;
		r0_n = r0->dw004C;
		r4_n->ptr0070 = (char *) &r4_n->ptr0004 + 0x0040;
	}
l000007BA:
	word32 r2_n = r4_n->dw0078;
	r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
	r4_n->dw0078 = r2_n + 0x01;
	vListInsertEnd((char *) &r4_n->ptr0004 + 0x04 + r0_n * 0x14, &r0->ptr0024);
	vPortExitCritical(cpsr);
	if (r4_n->dw0074 != 0x00 && (r4_n->ptr0004)->dw004C < r0->dw004C)
	{
		*globals->ptr0858 = 0x10000000;
		__dsb_sy();
		__isb_sy();
	}
}

// 0000085C: void prvAddCurrentTaskToDelayedList.isra.0(Register up32 r0)
void prvAddCurrentTaskToDelayedList.isra.0(up32 r0)
{
	struct Eq_n * r4_n = globals->ptr08B0;
	up32 r6_n = r4_n->dw0080;
	if (uxListRemove(&r4_n->ptr0004->dw0024) == 0x00)
		r4_n->dw007C &= ~(0x01 << (r4_n->ptr0004)->dw004C);
	up32 r5_n = r0 + r6_n;
	r4_n->ptr0004->dw0024 = r5_n;
	if (r6_n > r5_n)
	{
		struct Eq_n * r0_n = r4_n->ptr0070;
		struct Eq_n * r1_n = r4_n->ptr0004;
		vListInsert(r0_n, &r1_n->dw0024);
	}
	else
	{
		vListInsert(r4_n->ptr006C, &r4_n->ptr0004->dw0024);
		if (r5_n < r4_n->dw0084)
			r4_n->dw0084 = r5_n;
	}
}

// 000008B4: Register ui32 xTaskCreate(Register ui32 r0, Register word32 r1, Register ui32 r2, Register word32 r3, Register ptr32 cpsr, Stack int32 dwArg00, Stack (ptr32 (ptr32 Eq_n)) dwArg04)
ui32 xTaskCreate(ui32 r0, word32 r1, ui32 r2, word32 r3, ptr32 cpsr, int32 dwArg00, struct Eq_n ** dwArg04)
{
	struct Eq_n * r0_n = pvPortMalloc(r2 << 0x02, cpsr);
	if (r0_n == null)
		return ~0x00;
	ui32 r0_n;
	struct Eq_n * r0_n = pvPortMalloc(0x68, cpsr);
	if (r0_n != null)
	{
		r0_n->ptr0050 = r0_n;
		r0_n->b0065 = 0x00;
		prvInitialiseNewTask(r0, r1, r2, r3, dwArg00, dwArg04, r0_n, null);
		prvAddNewTaskToReadyList(r0_n, cpsr);
		r0_n = 0x01;
	}
	else
	{
		vPortFree();
		r0_n = ~0x00;
	}
	return r0_n;
}

// 0000091C: void xTaskCreateRestricted(Register (ptr32 Eq_n) r0, Register (ptr32 (ptr32 Eq_n)) r1, Register ptr32 cpsr)
void xTaskCreateRestricted(struct Eq_n * r0, struct Eq_n ** r1, ptr32 cpsr)
{
	if (r0->ptr0014 == null)
		return;
	struct Eq_n * r0_n = pvPortMalloc(0x68, cpsr);
	if (r0_n != null)
	{
		struct Eq_n * r1_n = r0->ptr0014;
		r0_n->b0065 = 0x01;
		word32 r3_n = r0->dw000C;
		ui32 r2_n = (word32) r0->w0008;
		int32 lr_n = r0->dw0010;
		r0_n->ptr0050 = r1_n;
		prvInitialiseNewTask(r0->dw0000, r0->dw0004, r2_n, r3_n, lr_n, r1, r0_n, (char *) &r0->ptr0014 + 0x04);
		prvAddNewTaskToReadyList(r0_n, cpsr);
	}
}

// 00000970: void vTaskAllocateMPURegions(Register word32 r0, Register (ptr32 Eq_n) r1)
void vTaskAllocateMPURegions(word32 r0, struct Eq_n * r1)
{
	if (r0 == 0x00)
	{
		word32 r0_n = globals->ptr098C->dw0004;
		vPortStoreTaskMPUSettings(r0_n + 0x04, r1, null, 0x00);
	}
	else
		vPortStoreTaskMPUSettings(r0 + 0x04, r1, null, 0x00);
}

// 00000990: void vTaskStartScheduler(Register ptr32 cpsr)
void vTaskStartScheduler(ptr32 cpsr)
{
	struct Eq_n * r4_n = globals->ptr09E0;
	word32 r0_n = xTaskCreate(globals->dw09E8, globals->dw09E4, 0x3B, 0x00, cpsr, 0x80000000, &r4_n->dw0084 + 0x01);
	if (r0_n != 0x01)
		return;
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	r4_n->dw0084 = ~0x00;
	r4_n->dw0074 = r0_n;
	r4_n->dw0080 = 0x00;
	xPortStartScheduler(cpsr);
}

// 000009EC: void vTaskEndScheduler(Register ptr32 cpsr)
void vTaskEndScheduler(ptr32 cpsr)
{
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	globals->ptr0A08->dw0074 = 0x00;
	vPortEndScheduler();
}

// 00000A0C: FlagGroup bool vTaskSuspendAll()
bool vTaskSuspendAll()
{
	struct Eq_n * r2_n = globals->ptr0A1C;
	word32 r3_n = r2_n->dw008C;
	r2_n->dw008C = r3_n + 0x01;
	return SLICE(cond(r3_n + 0x01), bool, 1);
}

// 00000A20: void xTaskGetTickCount()
void xTaskGetTickCount()
{
}

// 00000A2C: void xTaskGetTickCountFromISR()
void xTaskGetTickCountFromISR()
{
}

// 00000A38: void uxTaskGetNumberOfTasks()
void uxTaskGetNumberOfTasks()
{
}

// 00000A44: void pcTaskGetName(Register word32 r0)
void pcTaskGetName(word32 r0)
{
	if (r0 == 0x00)
		;
}

// 00000A58: void xTaskGenericNotify(Register (ptr32 Eq_n) r0, Register ui32 r1, Register up32 r2, Register (ptr32 ui32) r3, Register ptr32 cpsr)
void xTaskGenericNotify(struct Eq_n * r0, ui32 r1, up32 r2, ui32 * r3, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	if (r3 != null)
		*r3 = r0->dw0060;
	word32 r4_n = (word32) r0->b0064;
	r0->b0064 = 0x02;
	uint32 r4_n = (uint32) (byte) r4_n;
	if (r2 <= 0x04)
	{
		switch (r2 - 0x01)
		{
		case 0x00:
			r0->dw0060 = r1 | r0->dw0060;
			break;
		case 0x01:
			++r0->dw0060;
			if (r4_n == 0x01)
				goto l00000AA6;
			goto l00000A90;
		case 0x02:
l00000A8A:
			r0->dw0060 = r1;
			break;
		case 0x03:
			if (r4_n != 0x02)
				goto l00000A8A;
			goto l00000A92;
		}
	}
	if (r4_n == 0x01)
	{
l00000AA6:
		struct Eq_n * r5_n = globals->ptr0B04;
		uxListRemove((char *) r0 + 0x0024);
		uint32 r0_n = r0->dw004C;
		r5_n->dw007C = r4_n << r0_n | r5_n->dw007C;
		vListInsertEnd((char *) &r5_n->ptr0004 + 0x04 + r0_n * 0x14, (char *) r0 + 0x0024);
		if (r0->dw004C > (r5_n->ptr0004)->dw004C)
		{
			*globals->ptr0B08 = 0x10000000;
			__dsb_sy();
			__isb_sy();
			vPortExitCritical(cpsr);
			return;
		}
	}
l00000A90:
l00000A92:
	vPortExitCritical(cpsr);
}

// 00000B0C: void xTaskGenericNotifyFromISR(Register (ptr32 Eq_n) r0, Register ui32 r1, Register up32 r2, Register (ptr32 ui32) r3, Register ptr32 cpsr, Stack (ptr32 word32) dwArg00)
void xTaskGenericNotifyFromISR(struct Eq_n * r0, ui32 r1, up32 r2, ui32 * r3, ptr32 cpsr, word32 * dwArg00)
{
	Eq_n r5_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (r3 != null)
		*r3 = r0->dw0060;
	word32 r4_n = (word32) r0->b0064;
	r0->b0064 = 0x02;
	uint32 r4_n = (uint32) (byte) r4_n;
	if (r2 <= 0x04)
	{
		switch (r2 - 0x01)
		{
		case 0x00:
			r0->dw0060 = r1 | r0->dw0060;
			break;
		case 0x01:
			++r0->dw0060;
			if (r4_n == 0x01)
				goto l00000B64;
			goto l00000B4E;
		case 0x02:
l00000B48:
			r0->dw0060 = r1;
			break;
		case 0x03:
			if (r4_n != 0x02)
				goto l00000B48;
			goto l00000B50;
		}
	}
	if (r4_n == 0x01)
	{
l00000B64:
		struct Eq_n * r6_n = globals->ptr0BD0;
		if (r6_n->dw008C != 0x00)
			vListInsertEnd((char *) &r6_n->ptr0004 + 0x0054, (char *) r0 + 0x0038);
		else
		{
			uxListRemove((char *) r0 + 0x0024);
			uint32 r0_n = r0->dw004C;
			r6_n->dw007C = r4_n << r0_n | r6_n->dw007C;
			vListInsertEnd((char *) &r6_n->ptr0004 + 0x04 + r0_n * 0x14, (char *) r0 + 0x0024);
		}
		if (r0->dw004C > (r6_n->ptr0004)->dw004C)
		{
			if (dwArg00 != null)
			{
				*dwArg00 = 0x01;
				__msr(cpsr, r5_n);
				return;
			}
			r6_n->dw0090 = 0x01;
l00000B50:
			__msr(cpsr, r5_n);
			return;
		}
	}
l00000B4E:
	goto l00000B50;
}

// 00000BD4: void xTaskNotifyWait(Register word32 r0, Register word32 r1, Register (ptr32 ui32) r2, Register up32 r3, Register ptr32 cpsr)
void xTaskNotifyWait(word32 r0, word32 r1, ui32 * r2, up32 r3, ptr32 cpsr)
{
	struct Eq_n * r4_n = globals->ptr0C58;
	vPortEnterCritical(cpsr);
	if ((word32) r4_n->ptr0004->b0064 != 0x02)
	{
		struct Eq_n * r1_n = r4_n->ptr0004;
		r1_n->dw0060 &= ~r0;
		r4_n->ptr0004->b0064 = 0x01;
		if (r3 != 0x00)
		{
			prvAddCurrentTaskToDelayedList.isra.0(r3);
			*globals->ptr0C5C = 0x10000000;
			__dsb_sy();
			__isb_sy();
		}
	}
	vPortExitCritical(cpsr);
	vPortEnterCritical(cpsr);
	if (r2 != null)
		*r2 = r4_n->ptr0004->dw0060;
	if ((word32) r4_n->ptr0004->b0064 != 0x01)
	{
		struct Eq_n * r3_n = r4_n->ptr0004;
		r3_n->dw0060 &= ~r1;
	}
	r4_n->ptr0004->b0064 = 0x00;
	vPortExitCritical(cpsr);
}

// 00000C60: void vTaskNotifyGiveFromISR(Register (ptr32 Eq_n) r0, Register (ptr32 word32) r1, Register ptr32 cpsr)
void vTaskNotifyGiveFromISR(struct Eq_n * r0, word32 * r1, ptr32 cpsr)
{
	Eq_n r6_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	word32 r5_n = (word32) r0->b0064;
	r0->b0064 = 0x02;
	++r0->dw0060;
	uint32 r5_n = (uint32) (byte) r5_n;
	if (r5_n == 0x01)
	{
		struct Eq_n * r7_n = globals->ptr0CFC;
		if (r7_n->dw008C != 0x00)
			vListInsertEnd((char *) &r7_n->ptr0004 + 0x0054, (char *) r0 + 0x0038);
		else
		{
			uxListRemove((char *) r0 + 0x0024);
			uint32 r0_n = r0->dw004C;
			r7_n->dw007C = r5_n << r0_n | r7_n->dw007C;
			vListInsertEnd((char *) &r7_n->ptr0004 + 0x04 + r0_n * 0x14, (char *) r0 + 0x0024);
		}
		if (r0->dw004C > (r7_n->ptr0004)->dw004C)
		{
			if (r1 != null)
			{
				*r1 = 0x01;
				__msr(cpsr, r6_n);
				return;
			}
			r7_n->dw0090 = 0x01;
		}
	}
	__msr(cpsr, r6_n);
}

// 00000D00: void ulTaskNotifyTake(Register word32 r0, Register up32 r1, Register ptr32 cpsr)
void ulTaskNotifyTake(word32 r0, up32 r1, ptr32 cpsr)
{
	struct Eq_n * r4_n = globals->ptr0D64;
	vPortEnterCritical(cpsr);
	if (r4_n->ptr0004->dw0060 == 0x00)
	{
		r4_n->ptr0004->b0064 = 0x01;
		if (r1 != 0x00)
		{
			prvAddCurrentTaskToDelayedList.isra.0(r1);
			*globals->ptr0D68 = 0x10000000;
			__dsb_sy();
			__isb_sy();
		}
	}
	vPortExitCritical(cpsr);
	vPortEnterCritical(cpsr);
	word32 r5_n = r4_n->ptr0004->dw0060;
	if (r5_n != 0x00)
	{
		if (r0 == 0x00)
			r4_n->ptr0004->dw0060 = r5_n - 0x01;
		else
			r4_n->ptr0004->dw0060 = 0x00;
	}
	r4_n->ptr0004->b0064 = 0x00;
	vPortExitCritical(cpsr);
}

// 00000D6C: Register word32 xTaskIncrementTick()
word32 xTaskIncrementTick()
{
	word32 r6_n;
	struct Eq_n * r4_n = globals->ptr0E64;
	if (r4_n->dw008C != 0x00)
	{
		++r4_n->dw0098;
		r6_n = 0x00;
		goto l00000E28;
	}
	up32 r7_n = r4_n->dw0080;
	r4_n->dw0080 = r7_n + 0x01;
	if (r7_n == 0x01)
	{
		struct Eq_n * r3_n = r4_n->ptr006C;
		r4_n->ptr006C = r4_n->ptr0070;
		r4_n->ptr0070 = r3_n;
		++r4_n->dw0094;
		if (r4_n->ptr006C->dw0000 != 0x00)
		{
			r4_n->dw0084 = r4_n->ptr006C->ptr000C->ptr000C->dw0024;
			r6_n = 0x00;
			if (r7_n + 0x01 < r4_n->dw0084)
				goto l00000E14;
l00000DB2:
			r6_n = 0x00;
			word32 r8_n = globals->dw0E68;
			while (r4_n->ptr006C->dw0000 != 0x00)
			{
				struct Eq_n * r5_n = r4_n->ptr006C->ptr000C->ptr000C;
				up32 r3_n = r5_n->dw0024;
				if (r7_n + 0x01 < r3_n)
				{
					r4_n->dw0084 = r3_n;
					goto l00000E14;
				}
				uxListRemove(&r5_n->dw0024);
				if (r5_n->dw0048 != 0x00)
					uxListRemove(&r5_n->dw0024 + 0x05);
				uint32 r0_n = r5_n->dw004C;
				r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
				vListInsertEnd(r8_n + r0_n * 0x14, &r5_n->dw0024);
				if (r5_n->dw004C >= (r4_n->ptr0004)->dw004C)
					r6_n = 0x01;
			}
			r4_n->dw0084 = ~0x00;
l00000E14:
			if (*((char *) &(r4_n + ((r4_n->ptr0004)->dw004C * 0x14) / 0x009C)->ptr0004 + 0x04) >= 0x02)
				r6_n = 0x01;
l00000E28:
			if (r4_n->dw0090 != 0x00)
				r6_n = 0x01;
			return r6_n;
		}
		r4_n->dw0084 = ~0x00;
	}
	r6_n = 0x00;
	if (r7_n + 0x01 < r4_n->dw0084)
		goto l00000E14;
	goto l00000DB2;
}

// 00000E6C: Register word32 xTaskResumeAll(Register ptr32 cpsr)
word32 xTaskResumeAll(ptr32 cpsr)
{
	struct Eq_n * r4_n = globals->ptr0F40;
	vPortEnterCritical(cpsr);
	--r4_n->ptr008C;
	struct Eq_n * r5_n = r4_n->ptr008C;
	if (r5_n == null && r4_n->dw0000 != 0x00)
	{
		while (r4_n->dw0058 != 0x00)
		{
			r5_n = r4_n->ptr0064->ptr000C;
			uxListRemove((char *) r5_n + 0x0038);
			uxListRemove((char *) r5_n + 0x0024);
			uint32 r0_n = r5_n->dw004C;
			r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
			vListInsertEnd((char *) &r4_n->ptr0004 + 0x04 + r0_n * 0x14, (char *) r5_n + 0x0024);
			if (r5_n->dw004C >= (r4_n->ptr0004)->dw004C)
				r4_n->dw0090 = 0x01;
		}
		if (r5_n != null)
		{
			if (r4_n->ptr006C->dw0000 == 0x00)
				r4_n->dw0084 = ~0x00;
			else
				r4_n->dw0084 = r4_n->ptr006C->ptr000C->ptr000C->dw0024;
		}
		word32 r5_n = r4_n->dw0098;
		if (r5_n != 0x00)
		{
			do
			{
				if (xTaskIncrementTick() != 0x00)
					r4_n->dw0090 = 0x01;
				--r5_n;
			} while (r5_n != 0x00);
			r4_n->dw0098 = r5_n;
		}
		if (r4_n->dw0090 != 0x00)
		{
			*globals->ptr0F44 = 0x10000000;
			__dsb_sy();
			__isb_sy();
			vPortExitCritical(cpsr);
			return 0x01;
		}
	}
	vPortExitCritical(cpsr);
	return 0x00;
}

// 00000F48: void vTaskDelay(Register up32 r0, Register ptr32 cpsr)
void vTaskDelay(up32 r0, ptr32 cpsr)
{
	if (r0 != 0x00)
	{
		struct Eq_n * r2_n = globals->ptr0F7C;
		++r2_n->dw008C;
		prvAddCurrentTaskToDelayedList.isra.0(r0);
		if (xTaskResumeAll(cpsr) != 0x00)
			return;
	}
	*globals->ptr0F78 = 0x10000000;
	__dsb_sy();
	__isb_sy();
}

// 00000F80: void vTaskDelayUntil(Register (ptr32 up32) r0, Register word32 r1, Register ptr32 cpsr)
void vTaskDelayUntil(up32 * r0, word32 r1, ptr32 cpsr)
{
	struct Eq_n * r2_n = globals->ptr0FD4;
	up32 r3_n = *r0;
	++r2_n->dw008C;
	up32 r2_n = r2_n->dw0080;
	up32 r1_n = r1 + r3_n;
	if (r2_n < r3_n)
	{
		if (r3_n <= r1_n)
			goto l00000F9E;
	}
	else if (r3_n > r1_n)
		goto l00000FC0;
	if (r2_n >= r1_n)
	{
l00000F9E:
		*r0 = r1_n;
		if (xTaskResumeAll(cpsr) != 0x00)
			return;
		goto l00000FA6;
	}
l00000FC0:
	*r0 = r1_n;
	prvAddCurrentTaskToDelayedList.isra.0(r1_n - r2_n);
	if (xTaskResumeAll(cpsr) != 0x00)
		return;
l00000FA6:
	*globals->ptr0FD8 = 0x10000000;
	__dsb_sy();
	__isb_sy();
}

// 00000FDC: void vTaskPlaceOnEventList(Register (ptr32 Eq_n) r0, Register up32 r1)
void vTaskPlaceOnEventList(struct Eq_n * r0, up32 r1)
{
	vListInsert(r0, globals->ptr0FF4->dw0004 + 0x38);
	prvAddCurrentTaskToDelayedList.isra.0(r1);
}

// 00000FF8: void vTaskPlaceOnUnorderedEventList(Register (ptr32 Eq_n) r0, Register ui32 r1, Register up32 r2)
void vTaskPlaceOnUnorderedEventList(struct Eq_n * r0, ui32 r1, up32 r2)
{
	struct Eq_n * r3_n = globals->ptr1018;
	struct Eq_n * r3_n = r3_n->ptr0004;
	r3_n->ptr0004->dw0038 = r1 | 0x80000000;
	vListInsertEnd(r0, &r3_n->dw0038);
	prvAddCurrentTaskToDelayedList.isra.0(r2);
}

// 0000101C: Register (ptr32 Eq_n) xTaskRemoveFromEventList(Register (ptr32 Eq_n) r0)
struct Eq_n * xTaskRemoveFromEventList(struct Eq_n * r0)
{
	struct Eq_n * r0_n;
	struct Eq_n * r4_n = globals->ptr107C;
	struct Eq_n * r5_n = r0->ptr000C->ptr000C;
	uxListRemove((char *) r5_n + 0x0038);
	if (r4_n->dw008C == 0x00)
	{
		uxListRemove((char *) r5_n + 0x0024);
		uint32 r0_n = r5_n->dw004C;
		r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
		r0_n = (struct Eq_n *) ((char *) &r4_n->ptr0004 + 0x04 + r0_n * 0x14);
		vListInsertEnd(r0_n, (char *) r5_n + 0x0024);
	}
	else
	{
		vListInsertEnd((char *) &r4_n->ptr0004 + 0x0054, (char *) r5_n + 0x0038);
		r0_n = (struct Eq_n *) ((char *) &r4_n->ptr0004 + 0x0054);
	}
	if (r5_n->dw004C > (r4_n->ptr0004)->dw004C)
		r0_n = &globals->dw0001;
	r4_n->ptr0090 = r0_n;
	return null;
}

// 00001080: void xTaskRemoveFromUnorderedEventList(Register (ptr32 Eq_n) r0, Register ui32 r1)
void xTaskRemoveFromUnorderedEventList(struct Eq_n * r0, ui32 r1)
{
	struct Eq_n * r6_n = r0->ptr000C;
	r0->dw0000 = r1 | 0x80000000;
	uxListRemove(r0);
	struct Eq_n * r4_n = globals->ptr10D4;
	uxListRemove((char *) r6_n + 0x0024);
	uint32 r3_n = r6_n->dw004C;
	r4_n->dw007C = 0x01 << r3_n | r4_n->dw007C;
	vListInsertEnd((char *) &r4_n->ptr0004 + 0x04 + r3_n * 0x14, (char *) r6_n + 0x0024);
	r6_n->dw004C <= (r4_n->ptr0004)->dw004C;
	r4_n->dw0090 = 0x01;
}

// 000010D8: void vTaskSwitchContext()
void vTaskSwitchContext()
{
	struct Eq_n * r2_n = globals->ptr111C;
	word32 r3_n = r2_n->dw008C;
	if (r3_n != 0x00)
		r2_n->dw0090 = 0x01;
	else
	{
		struct Eq_n * r1_n;
		r2_n->dw0090 = r3_n;
		struct Eq_n * r0_n = r2_n + ((0x1F - (uint32) ((byte) __clz(r2_n->dw007C))) * 0x14) / 0x0094;
		struct Eq_n * r1_n = r0_n->ptr000C->ptr0004;
		r0_n->ptr000C = r1_n;
		r1_n = r1_n;
		if (r1_n == (char *) (&r0_n->ptr000C) + 0x04)
			r1_n = r1_n->ptr0004;
		word32 r3_n = r1_n->dw000C;
		if (r1_n == (char *) (&r0_n->ptr000C) + 0x04)
			r0_n->ptr000C = r1_n;
		r2_n->dw0004 = r3_n;
	}
}

// 00001120: Register word32 uxTaskResetEventItemValue()
word32 uxTaskResetEventItemValue()
{
	struct Eq_n * r3_n = globals->ptr1134;
	word32 r0_n = r3_n->ptr0004->dw0038;
	r3_n->ptr0004->dw0038 = 0x02 - (r3_n->ptr0004)->dw004C;
	return r0_n;
}

// 00001138: Register word32 xTaskGetCurrentTaskHandle()
word32 xTaskGetCurrentTaskHandle()
{
	return globals->ptr1140->dw0004;
}

// 00001144: void vTaskSetTimeOutState(Register (ptr32 Eq_n) r0)
void vTaskSetTimeOutState(struct Eq_n * r0)
{
	struct Eq_n * r3_n = globals->ptr1154;
	word32 r3_n = r3_n->dw0080;
	r0->dw0000 = r3_n->dw0094;
	r0->dw0004 = r3_n;
}

// 00001158: Register (ptr32 Eq_n) xTaskCheckForTimeOut(Register (ptr32 Eq_n) r0, Register (ptr32 up32) r1, Register ptr32 cpsr)
struct Eq_n * xTaskCheckForTimeOut(struct Eq_n * r0, up32 * r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	struct Eq_n * r3_n = globals->ptr11A8;
	up32 r5_n = r3_n->dw0080;
	up32 r0_n = r0->dw0004;
	if (r0->dw0000 == r3_n->dw0094 || r5_n < r0_n)
	{
		up32 r2_n = *r1;
		if (r5_n - r0_n < r2_n)
		{
			word32 r1_n = r3_n->dw0094;
			up32 r3_n = r3_n->dw0080;
			*r1 = r2_n - r5_n + r0_n;
			r0->dw0000 = r1_n;
			r0->dw0004 = r3_n;
			vPortExitCritical(cpsr);
			return null;
		}
	}
	vPortExitCritical(cpsr);
	return &globals->dw0001;
}

// 000011AC: void vTaskMissedYield()
void vTaskMissedYield()
{
	globals->ptr11B8->dw0090 = 0x01;
}

// 000011BC: void vTaskPriorityInherit(Register Eq_n r0)
void vTaskPriorityInherit(Eq_n r0)
{
	if (r0 == 0x00)
		return;
	struct Eq_n * r4_n = globals->ptr1248;
	uint32 r3_n = *((word32) r0 + 0x004C);
	if (r3_n >= (r4_n->ptr0004)->dw004C)
		return;
	if (*((word32) r0 + 0x0038) >= 0x00)
		*((word32) r0 + 0x0038) = 0x02 - (r4_n->ptr0004)->dw004C;
	word32 r5_n = globals->dw124C;
	if (*((word32) r0 + 0x0034) == r5_n + r3_n * 0x14)
	{
		if (uxListRemove((word32) r0 + 0x0024) == 0x00)
		{
			uint32 r2_n = *((word32) r0 + 0x004C);
			if (*((char *) &(r4_n + (r2_n * 0x14) / 0x0080)->ptr0004 + 0x04) == 0x00)
				r4_n->dw007C &= ~(0x01 << r2_n);
		}
		uint32 r2_n = r4_n->ptr0004->dw004C;
		ui32 r3_n = 0x01 << r2_n | r4_n->dw007C;
		*((word32) r0 + 0x004C) = r2_n;
		r4_n->dw007C = r3_n;
		struct Eq_n * r0_n = r5_n + r2_n * 0x14;
		vListInsertEnd(r0_n, (word32) r0 + 0x0024);
	}
	else
		*((word32) r0 + 0x004C) = r4_n->ptr0004->dw004C;
}

// 00001250: Register Eq_n xTaskPriorityDisinherit(Register Eq_n r0, Register out Eq_n lrOut)
Eq_n xTaskPriorityDisinherit(Eq_n r0, union Eq_n & lrOut)
{
	if (r0 == 0x00)
	{
		lrOut = lr;
		return 0x00;
	}
	else
	{
		uint32 r1_n = *((word32) r0 + 0x004C);
		word32 r3_n = *((word32) r0 + 0x005C);
		uint32 r2_n = *((word32) r0 + 88);
		*((word32) r0 + 0x005C) = r3_n - 0x01;
		if (r1_n == r2_n || r3_n != 0x01)
		{
			lrOut = lr;
			return 0x00;
		}
		else
		{
			struct Eq_n * r2_n;
			if (uxListRemove((word32) r0 + 0x0024) == 0x00)
			{
				uint32 r1_n = *((word32) r0 + 0x004C);
				r2_n = globals->ptr12CC;
				if (*((char *) (r2_n + (r1_n * 0x14) / 0x0080) + 0x08) == 0x00)
					r2_n->t007C &= ~(0x01 << r1_n);
			}
			else
				r2_n = globals->ptr12CC;
			uint32 r3_n = *((word32) r0 + 88);
			Eq_n lr_n = r2_n->t007C;
			word32 r0_n = globals->dw12D0;
			*((word32) r0 + 0x004C) = r3_n;
			*((word32) r0 + 0x0038) = 0x02 - r3_n;
			r2_n->t007C = 0x01 << r3_n | lr_n;
			vListInsertEnd(r0_n + r3_n * 0x14, (word32) r0 + 0x0024);
			lrOut = lr_n;
			return 0x01;
		}
	}
}

// 000012D4: Register (ptr32 Eq_n) pvTaskIncrementMutexHeldCount()
struct Eq_n * pvTaskIncrementMutexHeldCount()
{
	struct Eq_n * r3_n = globals->ptr12E8;
	if (r3_n->ptr0004 != null)
	{
		struct Eq_n * r1_n = r3_n->ptr0004;
		++r1_n->dw005C;
	}
	return r3_n->ptr0004;
}

// 000012F0: void prvRestoreContextOfFirstTask(Register ptr32 cpsr)
void prvRestoreContextOfFirstTask(ptr32 cpsr)
{
	__msr(cpsr, **globals->ptr1724);
	struct Eq_n * r1_n = *globals->ptr1330;
	union Eq_n * r0_n = r1_n->ptr0000;
	struct Eq_n * r2_n = globals->ptr1728;
	word32 r5_n = r1_n->dw0008;
	word32 r6_n = r1_n->dw000C;
	word32 r7_n = r1_n->dw0010;
	word32 r8_n = r1_n->dw0014;
	word32 r9_n = r1_n->dw0018;
	word32 r10_n = r1_n->dw001C;
	word32 fp_n = r1_n->dw0020;
	r2_n->dw0000 = r1_n->dw0004;
	r2_n->dw0004 = r5_n;
	r2_n->dw0008 = r6_n;
	r2_n->dw000C = r7_n;
	r2_n->dw0010 = r8_n;
	r2_n->dw0014 = r9_n;
	r2_n->dw0018 = r10_n;
	r2_n->dw001C = fp_n;
	__msr(cpsr, *r0_n);
	__msr(cpsr, (char *) r0_n + 0x0024);
	__msr(cpsr, 0x00);
}

// 00001334: void prvSVCHandler(Register Eq_n r0, Register ptr32 cpsr)
void prvSVCHandler(Eq_n r0, ptr32 cpsr)
{
	up32 r3_n = (word32) *(*((word32) r0 + 0x0018) - 0x02);
	if (r3_n == 0x01)
	{
		*globals->ptr1378 = 0x10000000;
		__dsb_sy();
		__isb_sy();
	}
	else if (r3_n < 0x01)
	{
		ui32 * r2_n = globals->ptr1374;
		*r2_n |= 0xBE000000;
		prvRestoreContextOfFirstTask(cpsr);
	}
	else
	{
		if (r3_n != 0x02)
			return;
		__msr(cpsr, __mrs(cpsr) & ~0x01);
	}
}

// 0000137C: Register (ptr32 Eq_n) pxPortInitialiseStack(Register (ptr32 Eq_n) r0, Register ui32 r1, Register word32 r2, Register int32 r3)
struct Eq_n * pxPortInitialiseStack(struct Eq_n * r0, ui32 r1, word32 r2, int32 r3)
{
	int32 r3_n;
	r3_n = r3;
	if (r3 == 0x01)
		r3_n = 0x02;
	if (r3 != 0x01)
		r3_n = 0x03;
	*(r0 - 0x0020) = r2;
	r0->dwFFFFFFF8 = r1 & ~0x01;
	r0->dwFFFFFFFC = 0x01000000;
	*(r0 - 0x0C) = 0x00;
	*(r0 - 0x0044) = r3_n;
	return r0 - 0x44;
}

// 000013B0: void xPortStartScheduler(Register ptr32 cpsr)
void xPortStartScheduler(ptr32 cpsr)
{
	ui32 * r3_n = globals->ptr14E8;
	word32 * r1_n = globals->ptr14EC;
	*r3_n |= 0x00FF0000;
	*r3_n |= 0xFF000000;
	if (*r1_n == 0x0800)
	{
		ui32 r2_n;
		ui32 r0_n = globals->dw14FC;
		uint32 r1_n = globals->dw1500 - r0_n;
		*globals->ptr1504 = r0_n | 0x10;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r2_n = globals->dw1508 | r2_n << 0x01;
					goto l0000142C;
				}
			}
			r2_n = globals->dw1538;
		}
		else
			r2_n = globals->dw1548;
l0000142C:
		ui32 r2_n;
		uint32 r1_n = globals->dw150C - r0_n;
		ui32 * r3_n = globals->ptr1504;
		*globals->ptr1510 = r2_n;
		*r3_n = r0_n | 0x11;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r2_n = globals->dw1514 | r2_n << 0x01;
					goto l0000145A;
				}
			}
			r2_n = globals->dw153C;
		}
		else
			r2_n = globals->dw1544;
l0000145A:
		ui32 r0_n;
		ui32 r3_n = globals->dw1518;
		ui32 * r0_n = globals->ptr1504;
		uint32 r1_n = globals->dw151C - r3_n;
		*globals->ptr1510 = r2_n;
		*r0_n = r3_n | 0x12;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r0_n = globals->dw1520 | r2_n << 0x01;
					goto l0000148A;
				}
			}
			r0_n = globals->dw1540;
		}
		else
			r0_n = globals->dw154C;
l0000148A:
		ui32 * r4_n = globals->ptr1504;
		ui32 r5_n = globals->dw1524;
		uint32 r1_n = globals->dw1528;
		*globals->ptr1510 = r0_n;
		*r4_n = r5_n;
		ui32 r3_n = 0x05;
		uint32 r2_n = 0x40;
		do
		{
			ui32 r3_n;
			++r3_n;
			r2_n <<= 0x01;
			if (r3_n == 0x1F)
			{
				r3_n = globals->dw1534;
				goto l000014AE;
			}
		} while (r2_n <= r1_n);
		r3_n = globals->dw152C | r3_n << 0x01;
l000014AE:
		ui32 * r2_n = globals->ptr1510;
		ui32 * r1_n = globals->ptr1530;
		*r2_n = r3_n;
		*r1_n |= 0x00010000;
		*(r2_n - 0x0C) |= 0x05;
	}
	word32 * r2_n = globals->ptr14F4;
	word32 * r3_n = globals->ptr14F8;
	*globals->ptr14F0 = 19999;
	*r2_n = 0x07;
	*r3_n = 0x00;
	__msr(cpsr, **globals->ptr1724);
	__cps();
	__cps();
	__dsb_sy();
	__isb_sy();
	__syscall(0x00);
}

// 00001550: void vPortEndScheduler()
void vPortEndScheduler()
{
}

// 00001554: void vPortStoreTaskMPUSettings(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register (ptr32 Eq_n) r2, Register ui32 r3)
void vPortStoreTaskMPUSettings(struct Eq_n * r0, struct Eq_n * r1, struct Eq_n * r2, ui32 r3)
{
	if (r1 == null)
	{
		ui32 r2_n;
		ui32 r3_n = globals->dw1668;
		uint32 r1_n = globals->dw166C - r3_n;
		r0->dw0000 = r3_n | 0x14;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r3_n >= r1_n)
				{
					r2_n = globals->dw1660 | r2_n << 0x01;
					goto l00001608;
				}
			}
			r2_n = globals->dw1664;
		}
		else
			r2_n = globals->dw1680;
l00001608:
		ui32 r2_n;
		ui32 r3_n = globals->dw1670;
		uint32 r1_n = globals->dw1674 - r3_n;
		r0->dw0004 = r2_n;
		r0[0x01] = (struct Eq_n) (r3_n | 0x15);
		if (r1_n > 0x20)
		{
			ui32 r2_n;
			uint32 r3_n = 0x40;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r2_n = globals->dw1678 | r2_n << 0x01;
					goto l00001634;
				}
			}
			r2_n = globals->dw167C;
		}
		else
			r2_n = globals->dw1684;
l00001634:
		r0[0x02] = (struct Eq_n) 22;
		r0->dw000C = r2_n;
		r0->dw0014 = 0x00;
		r0->dw001C = 0x00;
		r0[0x03] = (struct Eq_n) 0x17;
	}
	else
	{
		if (r3 != 0x00)
		{
			ui32 r4_n;
			r0->dw0000 = r2 | 0x14;
			if (r3 << 0x02 > 0x20)
			{
				uint32 r2_n = 0x40;
				ui32 r4_n;
				for (r4_n = 0x05; r4_n != 0x1F; ++r4_n)
				{
					r2_n <<= 0x01;
					if (r3 << 0x02 <= r2_n)
					{
						r4_n = globals->dw1660 | r4_n << 0x01;
						goto l000015D6;
					}
				}
				r4_n = globals->dw1664;
			}
			else
				r4_n = globals->dw1680;
l000015D6:
			r0->dw0004 = r4_n;
		}
		ui32 r5_n;
		for (r5_n = 0x05; r5_n != 0x08; ++r5_n)
		{
			uint32 r4_n = r1->dw0004;
			if (r4_n != 0x00)
			{
				ui32 r3_n;
				r0[0x01] = (struct Eq_n) (r1->dw0000 | (r5_n | 0x10));
				if (r4_n > 0x20)
				{
					uint32 r2_n = 0x40;
					ui32 r3_n;
					for (r3_n = 0x05; r3_n != 0x1F; ++r3_n)
					{
						r2_n <<= 0x01;
						if (r4_n <= r2_n)
						{
							r3_n = r3_n << 0x01;
							goto l00001586;
						}
					}
					r3_n = 0x3E;
				}
				else
					r3_n = 0x08;
l00001586:
				r0->dw000C = r3_n | (r1->dw0008 | 0x01);
			}
			else
			{
				r0->dw000C = r4_n;
				r0[0x01] = (struct Eq_n) (r5_n | 0x10);
			}
			++r1;
			++r0;
		}
	}
}

// 00001688: void xPortPendSVHandler(Register word32 r4, Register word32 r5, Register word32 r6, Register word32 r7, Register word32 r8, Register word32 r9, Register word32 r10, Register word32 fp, Register ptr32 cpsr)
void xPortPendSVHandler(word32 r4, word32 r5, word32 r6, word32 r7, word32 r8, word32 r9, word32 r10, word32 fp, ptr32 cpsr)
{
	Eq_n r0_n = __mrs(cpsr);
	struct Eq_n ** r3_n = globals->ptr16E0;
	struct Eq_n * r2_n = *r3_n;
	*((word32) r0_n - 0x0024) = __mrs(cpsr);
	*((word32) r0_n - 0x0020) = r4;
	*((word32) r0_n - 0x001C) = r5;
	*((word32) r0_n - 0x0018) = r6;
	*((word32) r0_n - 0x0014) = r7;
	*((word32) r0_n - 0x0010) = r8;
	*((word32) r0_n - 0x0C) = r9;
	*((word32) r0_n - 0x08) = r10;
	*((word32) r0_n - 0x04) = fp;
	r2_n->ptr0000 = r0_n - 0x0024;
	__msr(cpsr, 191);
	vTaskSwitchContext();
	__msr(cpsr, 0x00);
	struct Eq_n * r1_n = *r3_n;
	union Eq_n * r0_n = r1_n->ptr0000;
	struct Eq_n * r2_n = globals->ptr1728;
	word32 r5_n = r1_n->dw0008;
	word32 r6_n = r1_n->dw000C;
	word32 r7_n = r1_n->dw0010;
	word32 r8_n = r1_n->dw0014;
	word32 r9_n = r1_n->dw0018;
	word32 r10_n = r1_n->dw001C;
	word32 fp_n = r1_n->dw0020;
	r2_n->dw0000 = r1_n->dw0004;
	r2_n->dw0004 = r5_n;
	r2_n->dw0008 = r6_n;
	r2_n->dw000C = r7_n;
	r2_n->dw0010 = r8_n;
	r2_n->dw0014 = r9_n;
	r2_n->dw0018 = r10_n;
	r2_n->dw001C = fp_n;
	__msr(cpsr, *r0_n);
	__msr(cpsr, (char *) r0_n + 0x0024);
}

// 000016E4: void xPortSysTickHandler(Register ptr32 cpsr)
void xPortSysTickHandler(ptr32 cpsr)
{
	Eq_n r4_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (xTaskIncrementTick() != 0x00)
		*globals->ptr1710 = 0x10000000;
	__msr(cpsr, r4_n);
}

// 00001714: void vPortSVCHandler(Register ui32 lr, Register ptr32 cpsr)
void vPortSVCHandler(ui32 lr, ptr32 cpsr)
{
	if ((lr & 0x04) == 0x00)
		__mrs(cpsr);
	Eq_n r0_n = __mrs(cpsr);
	prvSVCHandler(r0_n, cpsr);
}

// 0000172C: Register ui32 pvPortMalloc(Register ui32 r0, Register ptr32 cpsr)
ui32 pvPortMalloc(ui32 r0, ptr32 cpsr)
{
	ui32 r4_n = r0;
	if (r0 << 0x001D != 0x00)
		r4_n = r0 & ~0x07;
	vTaskSuspendAll();
	struct Eq_n * r3_n = globals->ptr177C;
	word32 r4_n = r4_n + 0x08;
	if (r3_n->dw0000 == 0x00)
		Mem28[r3_n + 0x00:word32] = r3_n + 0x0C & ~0x07;
	up32 r2_n = r3_n->dw05C0;
	up32 r4_n = r4_n + r2_n;
	if (r4_n > 0x05B3 || r2_n >= r4_n)
	{
		xTaskResumeAll(cpsr);
		return 0x00;
	}
	else
	{
		ui32 r1_n = r3_n->dw0000;
		r3_n->dw05C0 = r4_n;
		xTaskResumeAll(cpsr);
		return r1_n + r2_n;
	}
}

// 00001780: void vPortFree()
void vPortFree()
{
}

// 00001784: void vPortInitialiseBlocks()
void vPortInitialiseBlocks()
{
	globals->ptr1790->dw05C0 = 0x00;
}

// 00001794: void xPortGetFreeHeapSize()
void xPortGetFreeHeapSize()
{
}

// 000017A8: void xEventGroupCreate(Register ptr32 cpsr)
void xEventGroupCreate(ptr32 cpsr)
{
	struct Eq_n * r0_n = pvPortMalloc(0x18, cpsr);
	if (r0_n != null)
	{
		r0_n->ptr0000 = null;
		vListInitialise(&r0_n->dw0004);
	}
}

// 000017C4: void xEventGroupWaitBits(Register (ptr32 ui32) r0, Register ui32 r1, Register word32 r2, Register word32 r3, Register ptr32 cpsr, Stack up32 dwArg00)
void xEventGroupWaitBits(ui32 * r0, ui32 r1, word32 r2, word32 r3, ptr32 cpsr, up32 dwArg00)
{
	Eq_n C_n = vTaskSuspendAll();
	ui32 r5_n = r1;
	ui32 r4_n = *r0;
	if (r3 == 0x00)
	{
		r4_n = (word32) C_n + (r4_n + r1);
		if (r4_n != 0x00)
		{
l000017DC:
			if (r2 != 0x00)
				*r0 = r4_n & ~r1;
l000017E8:
			xTaskResumeAll(cpsr);
			return;
		}
	}
	else if ((r1 & ~r4_n) == 0x00)
		goto l000017DC;
	if (dwArg00 == 0x00)
		goto l000017E8;
	ui32 r1_n = 0x01000000;
	if (r3 != 0x00)
		r1_n = 0x05000000;
	vTaskPlaceOnUnorderedEventList(r0 + 0x01, r1_n | r1, dwArg00);
	if (xTaskResumeAll(cpsr) == 0x00)
	{
		*globals->ptr1870 = 0x10000000;
		__dsb_sy();
		__isb_sy();
	}
	if (uxTaskResetEventItemValue() << 0x06 < 0x00)
		return;
	bool C_n = vPortEnterCritical(cpsr);
	ui32 r4_n = *r0;
	if (r3 == 0x00)
	{
		r5_n = r1 + r4_n + C_n;
		if (r5_n == 0x00)
			goto l0000185C;
	}
	else if ((r1 & ~r4_n) != 0x00)
		goto l0000185C;
	if (r2 != 0x00)
		*r0 = r4_n & ~r5_n;
l0000185C:
	vPortExitCritical(cpsr);
}

// 00001874: void xEventGroupClearBits(Register (ptr32 ui32) r0, Register word32 r1, Register ptr32 cpsr)
void xEventGroupClearBits(ui32 * r0, word32 r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	*r0 &= ~r1;
	vPortExitCritical(cpsr);
}

// 00001890: void xEventGroupSetBits(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ptr32 cpsr)
void xEventGroupSetBits(struct Eq_n * r0, ui32 r1, ptr32 cpsr)
{
	ui32 r7_n;
	vTaskSuspendAll();
	struct Eq_n * r0_n = r0->ptr0010;
	ui32 r1_n = r0->dw0000 | r1;
	r0->dw0000 = r1_n;
	if (&r0->dw0000 + 0x03 != r0_n)
	{
		ui32 r7_n = 0x00;
		do
		{
			ui32 r3_n = r0_n->dw0000;
			struct Eq_n * r4_n = r0_n->ptr0004;
			ui32 r2_n = r3_n & ~0xFF000000;
			if ((r3_n & 0x04000000) == 0x00)
			{
				r2_n = r2_n + r1_n + ((r3_n & 0x04000000) < 0x00);
				if (r2_n != 0x00)
				{
l000018B2:
					if (r3_n << 0x07 < 0x00)
						r7_n |= r2_n;
					xTaskRemoveFromUnorderedEventList(r0_n, r1_n | 0x02000000);
					r1_n = r0->dw0000;
				}
				r0_n = r4_n;
				if (&r0->dw0000 + 0x03 != r4_n)
					continue;
				break;
			}
			if ((r2_n & ~r1_n) == 0x00)
				goto l000018B2;
			r0_n = r4_n;
		} while (&r0->dw0000 + 0x03 != r4_n);
		r7_n = ~r7_n;
	}
	else
		r7_n = ~0x00;
	r0->dw0000 = r1_n & r7_n;
	xTaskResumeAll(cpsr);
}

// 000018F8: void xEventGroupSync(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2, Register up32 r3, Register ptr32 cpsr)
void xEventGroupSync(struct Eq_n * r0, ui32 r1, ui32 r2, up32 r3, ptr32 cpsr)
{
	vTaskSuspendAll();
	ui32 r4_n = r0->dw0000 | r1;
	xEventGroupSetBits(r0, r1, cpsr);
	ui32 r6_n = r2;
	if ((r2 & ~r4_n) != 0x00)
	{
		if (r3 != 0x00)
		{
			vTaskPlaceOnUnorderedEventList(&r0->dw0000 + 0x01, r2 | 0x05000000, r3);
			if (xTaskResumeAll(cpsr) == 0x00)
			{
				*globals->ptr1984 = 0x10000000;
				__dsb_sy();
				__isb_sy();
			}
			if (uxTaskResetEventItemValue() << 0x06 >= 0x00)
			{
				vPortEnterCritical(cpsr);
				ui32 r4_n = r0->dw0000;
				if ((r2 & ~r4_n) == 0x00)
					r6_n = r4_n & ~r2;
				r0->dw0000 = r6_n;
				vPortExitCritical(cpsr);
			}
			return;
		}
	}
	else
		r0->dw0000 &= ~r2;
	xTaskResumeAll(cpsr);
}

// 00001988: void xEventGroupGetBitsFromISR(Register ptr32 cpsr)
void xEventGroupGetBitsFromISR(ptr32 cpsr)
{
	Eq_n r3_n = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	__msr(cpsr, r3_n);
}

// 000019A4: void vEventGroupDelete(Register (ptr32 Eq_n) r0, Register ptr32 cpsr)
void vEventGroupDelete(struct Eq_n * r0, ptr32 cpsr)
{
	vTaskSuspendAll();
	while (r0->dw0004 != 0x00)
		xTaskRemoveFromUnorderedEventList(r0->ptr0010, 0x02000000);
	vPortFree();
	xTaskResumeAll(cpsr);
}

// 000019D0: void vEventGroupSetBitsCallback(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ptr32 cpsr)
void vEventGroupSetBitsCallback(struct Eq_n * r0, ui32 r1, ptr32 cpsr)
{
	xEventGroupSetBits(r0, r1, cpsr);
}

// 000019D4: void vEventGroupClearBitsCallback(Register (ptr32 ui32) r0, Register word32 r1, Register ptr32 cpsr)
void vEventGroupClearBitsCallback(ui32 * r0, word32 r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	*r0 &= ~r1;
	vPortExitCritical(cpsr);
}

// 00008000: void NmiSR()
void NmiSR()
{
	while (true)
		;
}

// 00008004: void FaultISR()
void FaultISR()
{
	while (true)
		;
}

// 00008008: void ResetISR(Register ptr32 cpsr)
void ResetISR(ptr32 cpsr)
{
	word32 * r3_n = globals->ptr802C;
	word32 * r0_n = globals->ptr8030;
	if (r3_n < r0_n)
	{
		word32 * r2_n = r3_n + ((r0_n + ~r3_n & ~0x03) + 0x04);
		do
		{
			*r3_n = 0x00;
			++r3_n;
		} while (r3_n != r2_n);
	}
	Main(cpsr);
}

// 00008034: void raise()
void raise()
{
	while (true)
		;
}

// 00008038: void vPrintTask(Register Eq_n lr, Register ptr32 cpsr)
void vPrintTask(Eq_n lr, ptr32 cpsr)
{
	ui32 r4_n = 0x00;
	union Eq_n * r5_n = globals->ptr8064;
	while (true)
	{
		lr = MPU_xQueueGenericReceive(*r5_n, fp - 0x0014, ~0x00, 0x00, lr, cpsr);
		OSRAMClear();
		++r4_n;
		OSRAMStringDraw(dwLoc14, r4_n & 0x3F, r4_n & 0x01);
	}
}

// 00008068: void vCheckTask(Register Eq_n lr, Register ptr32 cpsr)
void vCheckTask(Eq_n lr, ptr32 cpsr)
{
	MPU_xTaskGetTickCount(cpsr);
	union Eq_n * r5_n = globals->ptr809C;
	while (true)
	{
		MPU_vTaskDelayUntil(fp - 0x0018, 5000, cpsr);
		lr = MPU_xQueueGenericSend(*r5_n, fp - 0x0014, ~0x00, 0x00, lr, cpsr);
	}
}

// 000080A0: void Main(Register ptr32 cpsr)
void Main(ptr32 cpsr)
{
	MPU_xQueueGenericCreate(0x03, 0x04, cpsr);
	*globals->ptr80F0 = 0x03;
	OSRAMInit(0x00);
	MPU_xTaskCreate(globals->dw80F8, globals->dw80F4, 0x3B, 0x00, cpsr, 0x03, null);
	MPU_xTaskCreate(globals->dw8100, globals->dw80FC, 0x3B, 0x00, cpsr, 0x02, null);
	vTaskStartScheduler(cpsr);
	OSRAMStringDraw(globals->ptr8104, 0x00, 0x00);
	while (true)
		;
}

// 00008108: void vUART_ISR(Register Eq_n lr, Register ptr32 cpsr)
void vUART_ISR(Eq_n lr, ptr32 cpsr)
{
	struct Eq_n * r5_n = globals->ptr8174;
	Eq_n r0_n = UARTIntStatus(r5_n, 0x01);
	UARTIntClear(r5_n, r0_n);
	if (r0_n << 0x001B < 0x00 && *globals->ptr8178 << 0x0019 < 0x00)
		xQueueGenericSendFromISR(fp - 0x15, r0_n, fp - 0x0014, 0x00, lr, cpsr);
	if (r0_n << 0x001A < 0x00)
	{
		byte * r2_n = globals->ptr817C;
		up32 r3_n = (word32) *r2_n;
		if (r3_n <= 122)
		{
			ui32 r1_n = *globals->ptr8178;
			struct Eq_n * r1_n = r1_n << 0x001A;
			if (r1_n << 0x001A >= 0x00)
				r1_n = globals->ptr8174;
			r1_n->dw0000 = r3_n;
			*r2_n = (byte) (r3_n + 0x01);
		}
	}
	if (0x00 != 0x00)
		*globals->ptr8180 = 0x10000000;
}

// 00008184: Register word32 vSetErrorLED(Register ptr32 cpsr)
word32 vSetErrorLED(ptr32 cpsr)
{
	return vParTestSetLED(0x07, 0x01, cpsr);
}

// 0000818C: Register word32 prvSetAndCheckRegisters(Register ptr32 cpsr, Register out ptr32 r4Out, Register out ptr32 r5Out, Register out ptr32 r6Out, Register out ptr32 r7Out, Register out ptr32 r8Out)
word32 prvSetAndCheckRegisters(ptr32 cpsr, ptr32 & r4Out, ptr32 & r5Out, ptr32 & r6Out, ptr32 & r7Out, ptr32 & r8Out)
{
	if (false || (false || (false || (false || (false || (false || (false || (false || (false || (false || (false || (false || false))))))))))))
	{
		word32 r0_n = vSetErrorLED(cpsr);
		r4Out = <invalid>;
		r5Out = <invalid>;
		r6Out = <invalid>;
		r7Out = <invalid>;
		r8Out = <invalid>;
		return r0_n;
	}
	else
	{
		r4Out = <invalid>;
		r5Out = <invalid>;
		r6Out = <invalid>;
		r7Out = <invalid>;
		r8Out = <invalid>;
		return 11;
	}
}

// 00008210: void vApplicationIdleHook(Register (ptr32 Eq_n) r0, Register word32 r4, Register word32 r5, Register word32 r6, Register word32 r7, Register word32 r8, Register word32 lr, Register ptr32 cpsr)
void vApplicationIdleHook(struct Eq_n * r0, word32 r4, word32 r5, word32 r6, word32 r7, word32 r8, word32 lr, ptr32 cpsr)
{
	while (true)
	{
		lr = vCoRoutineSchedule(r0, r4, r5, r6, r7, r8, lr, cpsr, out cpsr);
		r0 = prvSetAndCheckRegisters(cpsr, out r4, out r5, out r6, out r7, out r8);
	}
}

// 00008220: void PDCInit()
void PDCInit()
{
	SysCtlPeripheralEnable(globals->dw828C);
	SysCtlPeripheralEnable(globals->dw8290);
	GPIODirModeSet((struct Eq_n *) 0x40004000, 0x34, 0x02);
	GPIODirModeSet((struct Eq_n *) 0x40004000, 0x08, 0x01);
	GPIOPadConfigSet((struct Eq_n *) 0x40004000, 0x04, 0x02, 0x0A);
	struct Eq_n * r5_n = globals->ptr8294;
	SSIConfig(r5_n, 0x00, 0x00, globals->dw8298, 0x08);
	SSIEnable(r5_n);
	GPIOPinWrite((word32 (*)[]) 0x40004000, 0x08, 0x00);
	GPIOPinWrite((word32 (*)[]) 0x40004000, 0x08, 0x08);
}

// 0000829C: Register (ptr32 Eq_n) PDCWrite(Register (ptr32 Eq_n) r0, Register ui32 r1)
struct Eq_n * PDCWrite(struct Eq_n * r0, ui32 r1)
{
	struct Eq_n * r4_n = globals->ptr82CC;
	SSIDataPut(r4_n, r0 & 0x0F);
	SSIDataPut(r4_n, r1);
	SSIDataGet(r4_n, fp - 0x0014);
	SSIDataGet(r4_n, fp - 0x0014);
	return r4_n;
}

// 000082D0: void vListInitialise(Register (ptr32 Eq_n) r0)
void vListInitialise(struct Eq_n * r0)
{
	r0->dw0008 = ~0x00;
	r0->dw0000 = 0x00;
	r0->ptr0004 = (word32 *) &r0->dw0008;
	r0->ptr000C = (word32 *) &r0->dw0008;
	r0->ptr0010 = (word32 *) &r0->dw0008;
}

// 000082E8: void vListInitialiseItem(Register (ptr32 Eq_n) r0)
void vListInitialiseItem(struct Eq_n * r0)
{
	r0->dw0010 = 0x00;
}

// 000082F0: void vListInsertEnd(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1)
void vListInsertEnd(struct Eq_n * r0, struct Eq_n * r1)
{
	struct Eq_n * r3_n = r0->ptr0004;
	word32 r2_n = r0->dw0000;
	r1->ptr0008 = r3_n->ptr0008;
	struct Eq_n * r4_n = r3_n->ptr0008;
	r1->ptr0004 = r3_n;
	r4_n->ptr0004 = r1;
	r3_n->ptr0008 = r1;
	r1->ptr0010 = r0;
	r0->dw0000 = r2_n + 0x01;
}

// 0000830C: FlagGroup bool vListInsert(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1)
bool vListInsert(struct Eq_n * r0, struct Eq_n * r1)
{
	struct Eq_n * r2_n;
	struct Eq_n * r3_n;
	up32 r5_n = r1->dw0000;
	if (!Z)
	{
		r2_n = (struct Eq_n *) (&r0->dw0000 + 0x02);
		while (true)
		{
			r3_n = r2_n->ptr0004;
			if (r5_n < r3_n->dw0000)
				break;
			r2_n = r3_n;
		}
	}
	else
	{
		r2_n = r0->ptr0010;
		r3_n = r2_n->ptr0004;
	}
	word32 r4_n = r0->dw0000;
	r1->ptr0004 = r3_n;
	r3_n->ptr0008 = r1;
	r1->ptr0008 = r2_n;
	r2_n->ptr0004 = r1;
	r1->ptr0010 = r0;
	r0->dw0000 = r4_n + 0x01;
	return SLICE(cond(r4_n + 0x01), bool, 2);
}

// 00008340: Register (ptr32 Eq_n) uxListRemove(Register (ptr32 Eq_n) r0)
struct Eq_n * uxListRemove(struct Eq_n * r0)
{
	struct Eq_n * r2_n = r0->ptr0010;
	struct Eq_n * r3_n = r0->ptr0004;
	r3_n->ptr0008 = r0->ptr0008;
	struct Eq_n * r4_n = r2_n->ptr0004;
	struct Eq_n * r1_n = r0->ptr0008;
	r1_n->ptr0004 = r3_n;
	if (r0 == r4_n)
		r2_n->ptr0004 = r1_n;
	word32 r3_n = r2_n->dw0000;
	r0->ptr0010 = null;
	r2_n->dw0000 = r3_n - 0x01;
	return r3_n - 0x01;
}

// 00008364: FlagGroup bool xQueueCRSend(Register Eq_n r0, Register Eq_n r1, Register Eq_n r2, Register Eq_n r7, Register Eq_n lr, Register ptr32 cpsr, Register out Eq_n r0Out)
bool xQueueCRSend(Eq_n r0, Eq_n r1, Eq_n r2, Eq_n r7, Eq_n lr, ptr32 cpsr, union Eq_n & r0Out)
{
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	vPortEnterCritical(cpsr);
	if (*((word32) r0 + 0x0038) == *((word32) r0 + 0x003C))
	{
		bool Z_n = vPortExitCritical(cpsr);
		if (r2 != 0x00)
		{
			bool Z_n = vCoRoutineAddToDelayedList(r2, (word32) r0 + 0x0010);
			__msr(cpsr, 0x00);
			r0Out = ~0x03;
			return Z_n;
		}
		else
		{
			__msr(cpsr, r2);
			r0Out = r2;
			return Z_n;
		}
	}
	vPortExitCritical(cpsr);
	__msr(cpsr, 0x00);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	Eq_n r2_n = *((word32) r0 + 0x0038);
	Eq_n r3_n = *((word32) r0 + 0x003C);
	Eq_n r0_n = 0x00;
	bool Z_n = SLICE(cond(r2_n - r3_n), bool, 2);
	if (r2_n < r3_n)
	{
		word32 lr_n;
		word32 r7_n;
		word32 r0_n;
		Z_n = prvCopyDataToQueue(r0, r1, 0x00, r7, lr, out r0_n, out r7_n, out lr_n);
		if (*((word32) r0 + 0x0024) != 0x00)
		{
			word32 r0_n;
			xCoRoutineRemoveFromEventList((word32) r0 + 0x0024, out r0_n);
			Z_n = SLICE(cond(r0_n), bool, 2);
			if (r0_n != 0x00)
			{
				r0_n = ~0x04;
				goto l000083AA;
			}
		}
		__msr(cpsr, 0x00);
		r0Out.u0 = 0x01;
		return Z_n;
	}
	else
	{
l000083AA:
		__msr(cpsr, 0x00);
		r0Out = r0_n;
		return Z_n;
	}
}

// 00008400: FlagGroup bool xQueueCRReceive(Register Eq_n r0, Register Eq_n r1, Register Eq_n r2, Register Eq_n r6, Register Eq_n r7, Register Eq_n lr, Register ptr32 cpsr, Register out Eq_n r0Out, Register out Eq_n r6Out, Register out Eq_n r7Out, Register out Eq_n lrOut)
bool xQueueCRReceive(Eq_n r0, Eq_n r1, Eq_n r2, Eq_n r6, Eq_n r7, Eq_n lr, ptr32 cpsr, union Eq_n & r0Out, union Eq_n & r6Out, union Eq_n & r7Out, union Eq_n & lrOut)
{
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	Eq_n r5_n = *((word32) r0 + 0x0038);
	if (r5_n == 0x00)
	{
		bool Z_n = SLICE(cond(r2), bool, 2);
		if (r2 != 0x00)
		{
			bool Z_n = vCoRoutineAddToDelayedList(r2, (word32) r0 + 0x0024);
			__msr(cpsr, r5_n);
			r0Out = ~0x03;
			r6Out = r6;
			r7Out = r7;
			lrOut = lr;
			return Z_n;
		}
		else
		{
			__msr(cpsr, r2);
			r0Out = r2;
			r6Out = r6;
			r7Out = r7;
			lrOut = lr;
			return Z_n;
		}
	}
	Eq_n r0_n;
	__msr(cpsr, 0x00);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	Eq_n r2_n = *((word32) r0 + 0x0038);
	if (r2_n != 0x00)
	{
		Eq_n r1_n;
		Eq_n r2_n = *((word32) r0 + 0x0040);
		Eq_n r3_n = *((word32) r0 + 0x04);
		word32 r1_n = Mem11[r0 + 0x0C:word32] + r2_n;
		Eq_n r3_n = *((word32) r0 + 0x0038);
		*((word32) r0 + 0x0C) = r1_n;
		r1_n = r1_n;
		if (r1_n >= r3_n)
			r1_n = *r0;
		*((word32) r0 + 0x0038) = (word32) r3_n - 0x01;
		if (r1_n >= r3_n)
			*((word32) r0 + 0x0C) = r1_n;
		struct Eq_n * r4_n;
		word32 r5_n;
		Z = memcpy(r1, r1_n, r2_n, r0, r5_n, r6, r7, lr, out r4_n, out r5_n, out r6, out r7, out lr);
		if (r4_n->dw0010 != 0x00)
		{
			word32 r0_n;
			xCoRoutineRemoveFromEventList(&r4_n->dw0010, out r0_n);
			Z = SLICE(cond(r0_n), bool, 2);
			if (r0_n != 0x00)
			{
				r0_n = ~0x04;
l00008440:
				__msr(cpsr, 0x00);
				r0Out = r0_n;
				r6Out = r6;
				r7Out = r7;
				lrOut = lr;
				return Z;
			}
		}
		__msr(cpsr, 0x00);
		r0Out.u0 = 0x01;
		r6Out = r6;
		r7Out = r7;
		lrOut = lr;
		return Z;
	}
	else
	{
		r0_n = r2_n;
		goto l00008440;
	}
}

// 000084A0: void xQueueCRSendFromISR(Register Eq_n r0, Register Eq_n r1, Register word32 r2, Register Eq_n r7, Register Eq_n lr)
void xQueueCRSendFromISR(Eq_n r0, Eq_n r1, word32 r2, Eq_n r7, Eq_n lr)
{
	if (*((word32) r0 + 0x0038) < *((word32) r0 + 0x003C))
	{
		word32 lr_n;
		word32 r7_n;
		word32 r0_n;
		prvCopyDataToQueue(r0, r1, 0x00, r7, lr, out r0_n, out r7_n, out lr_n);
		if (r2 == 0x00 && *((word32) r0 + 0x0024) != 0x00)
		{
			word32 r0_n;
			xCoRoutineRemoveFromEventList((word32) r0 + 0x0024, out r0_n);
		}
	}
}

// 000084D4: void xQueueCRReceiveFromISR(Register Eq_n r0, Register Eq_n r1, Register Eq_n r2)
void xQueueCRReceiveFromISR(Eq_n r0, Eq_n r1, Eq_n r2)
{
	if (*((word32) r0 + 0x0038) == 0x00)
		return;
	Eq_n r3_n;
	Eq_n lr_n = *((word32) r0 + 0x0040);
	Eq_n r4_n = *((word32) r0 + 0x04);
	word32 r3_n = Mem15[r0 + 0x0C:word32] + lr_n;
	Eq_n r7_n = *((word32) r0 + 0x0038);
	*((word32) r0 + 0x0C) = r3_n;
	r3_n = r3_n;
	if (r3_n >= r4_n)
		r3_n = *r0;
	if (r3_n >= r4_n)
		*((word32) r0 + 0x0C) = r3_n;
	*((word32) r0 + 0x0038) = (word32) r7_n - 0x01;
	word32 r6_n;
	struct Eq_n * r4_n;
	word32 * r5_n;
	word32 r7_n;
	word32 lr_n;
	memcpy(r1, r3_n, lr_n, r0, r2, r1, (word32) r7_n - 0x01, lr_n, out r4_n, out r5_n, out r6_n, out r7_n, out lr_n);
	if (*r5_n != 0x00 || r4_n->dw0010 == 0x00)
		return;
	word32 r0_n;
	xCoRoutineRemoveFromEventList(&r4_n->dw0010, out r0_n);
	if (r0_n == 0x00)
		return;
	*r5_n = 0x01;
}

// 0000852C: void prvIdleTask(Register (ptr32 Eq_n) r0, Register word32 r4, Register word32 r5, Register word32 r6, Register word32 r7, Register word32 r8, Register word32 lr, Register ptr32 cpsr)
void prvIdleTask(struct Eq_n * r0, word32 r4, word32 r5, word32 r6, word32 r7, word32 r8, word32 lr, ptr32 cpsr)
{
	vApplicationIdleHook(r0, r4, r5, r6, r7, r8, lr, cpsr);
}

// 00008534: void xTaskNotifyStateClear(Register (ptr32 Eq_n) r0, Register ptr32 cpsr)
void xTaskNotifyStateClear(struct Eq_n * r0, ptr32 cpsr)
{
	struct Eq_n * r4_n;
	if (r0 != null)
		r4_n = r0;
	else
		r4_n = globals->ptr8560->ptr0004;
	vPortEnterCritical(cpsr);
	word32 r3_n = (word32) r4_n->b0064;
	if (r3_n == 0x02)
		r3_n = 0x00;
	r4_n->b0064 = (byte) r3_n;
	vPortExitCritical(cpsr);
}

// 00008564: Register word32 xPortRaisePrivilege(Register ptr32 cpsr)
word32 xPortRaisePrivilege(ptr32 cpsr)
{
	(__mrs(cpsr) & 0x01) == 0x00;
	__syscall(0x02);
	return 0x01;
}

// 00008578: FlagGroup bool vPortEnterCritical(Register ptr32 cpsr)
bool vPortEnterCritical(ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	word32 * r2_n = globals->ptr85AC;
	++*r2_n;
	bool C_n = SLICE(cond(r0_n - 0x01), bool, 1);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
	return C_n;
}

// 000085B0: FlagGroup bool vPortExitCritical(Register ptr32 cpsr)
bool vPortExitCritical(ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	word32 * r2_n = globals->ptr85D8;
	word32 r3_n = *r2_n;
	*r2_n = r3_n - 0x01;
	if (r3_n == 0x01)
		__msr(cpsr, r3_n - 0x01);
	bool Z_n = SLICE(cond(r0_n - 0x01), bool, 2);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
	return Z_n;
}

// 000085DC: void vParTestInitialise()
void vParTestInitialise()
{
	PDCInit();
	ui32 r1_n = (word32) *globals->ptr85F0;
	PDCWrite(&globals->dw0005, r1_n);
}

// 000085F4: Register up32 vParTestSetLED(Register up32 r0, Register word32 r1, Register ptr32 cpsr)
up32 vParTestSetLED(up32 r0, word32 r1, ptr32 cpsr)
{
	up32 r0_n = MPU_vTaskSuspendAll(cpsr);
	if (r0 <= 0x07)
	{
		byte * r3_n = globals->ptr862C;
		uint32 r0_n = (uint32) (byte) (0x01 << r0);
		ui32 r2_n = (word32) *r3_n;
		if (r1 != 0x00)
			*r3_n = (byte) (r0_n | r2_n);
		else
			*r3_n = (byte) (r2_n & ~r0_n);
		r0_n = PDCWrite(&globals->dw0005, (word32) *r3_n);
	}
	MPU_xTaskResumeAll(cpsr);
	return r0_n;
}

// 00008630: void vParTestToggleLED(Register up32 r0, Register ptr32 cpsr)
void vParTestToggleLED(up32 r0, ptr32 cpsr)
{
	MPU_vTaskSuspendAll(cpsr);
	if (r0 <= 0x07)
	{
		byte * r3_n = globals->ptr866C;
		ui32 r0_n = 0x01 << r0;
		uint32 r2_n = (uint32) (byte) r0_n + (word32) (*r3_n) + (r0 < 0x07);
		if (r2_n == 0x00)
			*r3_n = (byte) (r2_n | (word32) (*r3_n));
		else
			*r3_n = (byte) ((word32) *r3_n & ~r0_n);
		PDCWrite(&globals->dw0005, (word32) *r3_n);
	}
	MPU_xTaskResumeAll(cpsr);
}

// 00008670: void prvFlashCoRoutine(Register (ptr32 Eq_n) r0, Register Eq_n r7, Register Eq_n lr, Register ptr32 cpsr)
void prvFlashCoRoutine(struct Eq_n * r0, Eq_n r7, Eq_n lr, ptr32 cpsr)
{
	union Eq_n * r5_n;
	Eq_n r6_n;
	word32 r0_n;
	word32 r3_n = (word32) r0->w0034;
	if (r3_n != 0x01C2)
	{
		if (r3_n == 0x01C3)
		{
			r5_n = globals->ptr86E0;
			r6_n = fp - 0x0014;
			goto l00008690;
		}
		if (r3_n != 0x00)
			return;
		r5_n = globals->ptr86E0;
		r6_n = fp - 0x0014;
l00008696:
		bool Z_n = xQueueCRReceive(*r5_n, r6_n, ~0x00, r6_n, r7, lr, cpsr, out r0_n, out r6_n, out r7, out lr);
		if (Z_n)
		{
			r0->w0034 = 0x01C2;
			return;
		}
		if (!Z_n)
		{
l000086AA:
			if (r0_n != 0x01)
			{
				*globals->ptr86E4 = 0x00;
				goto l00008696;
			}
l00008690:
			vParTestToggleLED(dwLoc14, cpsr);
			goto l00008696;
		}
	}
	else
	{
		r5_n = globals->ptr86E0;
		if (xQueueCRReceive(*r5_n, fp - 0x0014, 0x00, fp - 0x0014, r7, lr, cpsr, out r0_n, out r6_n, out r7, out lr))
			goto l000086AA;
	}
	r0->w0034 = 0x01C3;
}

// 000086E8: void prvFixedDelayCoRoutine(Register (ptr32 Eq_n) r0, Register ui32 r1, Register Eq_n r7, Register Eq_n lr, Register ptr32 cpsr)
void prvFixedDelayCoRoutine(struct Eq_n * r0, ui32 r1, Eq_n r7, Eq_n lr, ptr32 cpsr)
{
	Eq_n r0_n;
	bool Z_n;
	word32 r0_n;
	up32 r3_n = (word32) r0->w0034;
	if (r3_n != 0x0182)
	{
		if (r3_n > 0x0182)
		{
			if (r3_n == 0x0183)
				goto l00008702;
			if (r3_n != 0x0196)
				return;
		}
		else if (r3_n != 0x00)
			return;
		Z_n = xQueueCRSend(*globals->ptr877C, fp - 0x0C, 0x00, r7, lr, cpsr, out r0_n);
		if (Z_n)
		{
			r0->w0034 = 0x0182;
			return;
		}
	}
	else
		Z_n = xQueueCRSend(*globals->ptr877C, fp - 0x0C, 0x00, r7, lr, cpsr, out r0_n);
	if (Z_n)
	{
		r0->w0034 = 0x0183;
		return;
	}
	if (r0_n != 0x01)
	{
		*globals->ptr8780 = 0x00;
		r0_n = globals->ptr8778[r1];
		if (r0_n == 0x00)
		{
l0000870C:
			r0->w0034 = 0x0196;
			return;
		}
l0000875E:
		vCoRoutineAddToDelayedList(r0_n, null);
		goto l0000870C;
	}
l00008702:
	r0_n = globals->ptr8778[r1];
	if (r0_n == 0x00)
		goto l0000870C;
	goto l0000875E;
}

// 00008784: void vStartFlashCoRoutines(Register (ptr32 Eq_n) r0, Register ptr32 cpsr)
void vStartFlashCoRoutines(struct Eq_n * r0, ptr32 cpsr)
{
	if (r0 >= &globals->t0008)
		r0 = &globals->t0008;
	MPU_xQueueGenericCreate(0x01, 0x04, cpsr);
	*globals->ptr87C4 = 0x01;
	if (0x01 == 0x00)
		return;
	if (r0 != null)
	{
		struct Eq_n * r4_n = null;
		struct Eq_n * r6_n = globals->ptr87C8;
		do
		{
			xCoRoutineCreate(r6_n, 0x00, r4_n, cpsr);
			r4_n = (struct Eq_n *) ((char *) &r4_n->ptr0000 + 0x01);
		} while (r4_n != r0);
	}
	struct Eq_n * r0_n = globals->ptr87CC;
	xCoRoutineCreate(r0_n, 0x01, null, cpsr);
}

// 000087D0: void xAreFlashCoRoutinesStillRunning()
void xAreFlashCoRoutinesStillRunning()
{
}

// 000087DC: void MPU_xTaskCreateRestricted(Register (ptr32 Eq_n) r0, Register (ptr32 (ptr32 Eq_n)) r1, Register ptr32 cpsr)
void MPU_xTaskCreateRestricted(struct Eq_n * r0, struct Eq_n ** r1, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xTaskCreateRestricted(r0, r1, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008808: void MPU_xTaskCreate(Register ui32 r0, Register word32 r1, Register ui32 r2, Register word32 r3, Register ptr32 cpsr, Stack int32 dwArg00, Stack (ptr32 (ptr32 Eq_n)) dwArg04)
void MPU_xTaskCreate(ui32 r0, word32 r1, ui32 r2, word32 r3, ptr32 cpsr, int32 dwArg00, struct Eq_n ** dwArg04)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xTaskCreate(r0, r1, r2, r3, cpsr, dwArg00, dwArg04);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 0000884C: void MPU_vTaskAllocateMPURegions(Register word32 r0, Register (ptr32 Eq_n) r1, Register ptr32 cpsr)
void MPU_vTaskAllocateMPURegions(word32 r0, struct Eq_n * r1, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	vTaskAllocateMPURegions(r0, r1);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008874: void MPU_vTaskDelayUntil(Register (ptr32 up32) r0, Register word32 r1, Register ptr32 cpsr)
void MPU_vTaskDelayUntil(up32 * r0, word32 r1, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	vTaskDelayUntil(r0, r1, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 0000889C: void MPU_vTaskDelay(Register up32 r0, Register ptr32 cpsr)
void MPU_vTaskDelay(up32 r0, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	vTaskDelay(r0, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 000088C0: Register ui32 MPU_vTaskSuspendAll(Register ptr32 cpsr)
ui32 MPU_vTaskSuspendAll(ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	vTaskSuspendAll();
	if (r0_n != 0x01)
	{
		Eq_n r0_n = __mrs(cpsr);
		__msr(cpsr, r0_n | 0x01);
		r0_n = r0_n | 0x01;
	}
	return r0_n;
}

// 000088E0: void MPU_xTaskResumeAll(Register ptr32 cpsr)
void MPU_xTaskResumeAll(ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xTaskResumeAll(cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008904: void MPU_xTaskGetTickCount(Register ptr32 cpsr)
void MPU_xTaskGetTickCount(ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xTaskGetTickCount();
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008928: void MPU_uxTaskGetNumberOfTasks(Register ptr32 cpsr)
void MPU_uxTaskGetNumberOfTasks(ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	uxTaskGetNumberOfTasks();
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 0000894C: void MPU_pcTaskGetName(Register word32 r0, Register ptr32 cpsr)
void MPU_pcTaskGetName(word32 r0, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	pcTaskGetName(r0);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008974: void MPU_vTaskSetTimeOutState(Register (ptr32 Eq_n) r0, Register ptr32 cpsr)
void MPU_vTaskSetTimeOutState(struct Eq_n * r0, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	vTaskSetTimeOutState(r0);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008998: void MPU_xTaskCheckForTimeOut(Register (ptr32 Eq_n) r0, Register (ptr32 up32) r1, Register ptr32 cpsr)
void MPU_xTaskCheckForTimeOut(struct Eq_n * r0, up32 * r1, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xTaskCheckForTimeOut(r0, r1, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 000089C4: void MPU_xTaskGenericNotify(Register (ptr32 Eq_n) r0, Register ui32 r1, Register up32 r2, Register (ptr32 ui32) r3, Register ptr32 cpsr)
void MPU_xTaskGenericNotify(struct Eq_n * r0, ui32 r1, up32 r2, ui32 * r3, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xTaskGenericNotify(r0, r1, r2, r3, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 000089FC: void MPU_xTaskNotifyWait(Register word32 r0, Register word32 r1, Register (ptr32 ui32) r2, Register up32 r3, Register ptr32 cpsr)
void MPU_xTaskNotifyWait(word32 r0, word32 r1, ui32 * r2, up32 r3, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xTaskNotifyWait(r0, r1, r2, r3, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008A34: void MPU_ulTaskNotifyTake(Register word32 r0, Register up32 r1, Register ptr32 cpsr)
void MPU_ulTaskNotifyTake(word32 r0, up32 r1, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	ulTaskNotifyTake(r0, r1, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008A60: void MPU_xTaskNotifyStateClear(Register (ptr32 Eq_n) r0, Register ptr32 cpsr)
void MPU_xTaskNotifyStateClear(struct Eq_n * r0, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xTaskNotifyStateClear(r0, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008A88: void MPU_xQueueGenericCreate(Register ui32 r0, Register ui32 r1, Register ptr32 cpsr)
void MPU_xQueueGenericCreate(ui32 r0, ui32 r1, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xQueueGenericCreate(r0, r1, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008AB8: void MPU_xQueueGenericReset(Register (ptr32 Eq_n) r0, Register word32 r1, Register ptr32 cpsr)
void MPU_xQueueGenericReset(struct Eq_n * r0, word32 r1, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xQueueGenericReset(r0, r1, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008AE4: Register Eq_n MPU_xQueueGenericSend(Register Eq_n r0, Register Eq_n r1, Register up32 r2, Register Eq_n r3, Register Eq_n lr, Register ptr32 cpsr)
Eq_n MPU_xQueueGenericSend(Eq_n r0, Eq_n r1, up32 r2, Eq_n r3, Eq_n lr, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	Eq_n lr_n = xQueueGenericSend(r0, r1, r2, r3, lr, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
	return lr_n;
}

// 00008B1C: void MPU_uxQueueMessagesWaiting(Register ptr32 cpsr)
void MPU_uxQueueMessagesWaiting(ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	uxQueueMessagesWaiting(cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008B44: void MPU_uxQueueSpacesAvailable(Register ptr32 cpsr)
void MPU_uxQueueSpacesAvailable(ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	uxQueueSpacesAvailable(cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008B6C: Register Eq_n MPU_xQueueGenericReceive(Register Eq_n r0, Register Eq_n r1, Register up32 r2, Register word32 r3, Register Eq_n lr, Register ptr32 cpsr)
Eq_n MPU_xQueueGenericReceive(Eq_n r0, Eq_n r1, up32 r2, word32 r3, Eq_n lr, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	Eq_n lr_n;
	xQueueGenericReceive(r0, r1, r2, r3, lr, cpsr, out lr_n);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
	return lr_n;
}

// 00008BA4: void MPU_xQueuePeekFromISR(Register Eq_n r0, Register Eq_n r1, Register Eq_n r7, Register Eq_n lr, Register ptr32 cpsr)
void MPU_xQueuePeekFromISR(Eq_n r0, Eq_n r1, Eq_n r7, Eq_n lr, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xQueuePeekFromISR(r0, r1, r7, lr, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008BD0: void MPU_xQueueGetMutexHolder(Register (ptr32 word32) r0, Register ptr32 cpsr)
void MPU_xQueueGetMutexHolder(word32 * r0, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xQueueGetMutexHolder(r0, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008BF8: void MPU_xQueueCreateMutex(Register Eq_n lr, Register ptr32 cpsr)
void MPU_xQueueCreateMutex(Eq_n lr, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xQueueCreateMutex(lr, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008C20: void MPU_xQueueTakeMutexRecursive(Register Eq_n r0, Register up32 r1, Register Eq_n lr, Register ptr32 cpsr)
void MPU_xQueueTakeMutexRecursive(Eq_n r0, up32 r1, Eq_n lr, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xQueueTakeMutexRecursive(r0, r1, lr, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008C4C: void MPU_xQueueGiveMutexRecursive(Register Eq_n r0, Register Eq_n lr, Register ptr32 cpsr)
void MPU_xQueueGiveMutexRecursive(Eq_n r0, Eq_n lr, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xQueueGiveMutexRecursive(r0, lr, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008C74: void MPU_vQueueDelete(Register ptr32 cpsr)
void MPU_vQueueDelete(ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	vQueueDelete();
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008C98: void MPU_pvPortMalloc(Register ui32 r0, Register ptr32 cpsr)
void MPU_pvPortMalloc(ui32 r0, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	pvPortMalloc(r0, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008CC0: void MPU_vPortFree(Register ptr32 cpsr)
void MPU_vPortFree(ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	vPortFree();
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008CE4: void MPU_vPortInitialiseBlocks(Register ptr32 cpsr)
void MPU_vPortInitialiseBlocks(ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	vPortInitialiseBlocks();
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008D04: void MPU_xPortGetFreeHeapSize(Register ptr32 cpsr)
void MPU_xPortGetFreeHeapSize(ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xPortGetFreeHeapSize();
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008D28: void MPU_xEventGroupCreate(Register ptr32 cpsr)
void MPU_xEventGroupCreate(ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xEventGroupCreate(cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008D4C: void MPU_xEventGroupWaitBits(Register (ptr32 ui32) r0, Register ui32 r1, Register word32 r2, Register word32 r3, Register ptr32 cpsr, Stack up32 dwArg00)
void MPU_xEventGroupWaitBits(ui32 * r0, ui32 r1, word32 r2, word32 r3, ptr32 cpsr, up32 dwArg00)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xEventGroupWaitBits(r0, r1, r2, r3, cpsr, dwArg00);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008D8C: void MPU_xEventGroupClearBits(Register (ptr32 ui32) r0, Register word32 r1, Register ptr32 cpsr)
void MPU_xEventGroupClearBits(ui32 * r0, word32 r1, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xEventGroupClearBits(r0, r1, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008DB8: void MPU_xEventGroupSetBits(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ptr32 cpsr)
void MPU_xEventGroupSetBits(struct Eq_n * r0, ui32 r1, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xEventGroupSetBits(r0, r1, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008DE4: void MPU_xEventGroupSync(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2, Register up32 r3, Register ptr32 cpsr)
void MPU_xEventGroupSync(struct Eq_n * r0, ui32 r1, ui32 r2, up32 r3, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	xEventGroupSync(r0, r1, r2, r3, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008E1C: void MPU_vEventGroupDelete(Register (ptr32 Eq_n) r0, Register ptr32 cpsr)
void MPU_vEventGroupDelete(struct Eq_n * r0, ptr32 cpsr)
{
	ui32 r0_n = xPortRaisePrivilege(cpsr);
	vEventGroupDelete(r0, cpsr);
	if (r0_n != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008E40: void xCoRoutineCreate(Register (ptr32 Eq_n) r0, Register uint32 r1, Register (ptr32 Eq_n) r2, Register ptr32 cpsr)
void xCoRoutineCreate(struct Eq_n * r0, uint32 r1, struct Eq_n * r2, ptr32 cpsr)
{
	uint32 r5_n = r1;
	struct Eq_n * r0_n = pvPortMalloc(0x38, cpsr);
	if (r0_n == null)
		return;
	struct Eq_n * r7_n = globals->ptr8EEC;
	if (r7_n->ptr0000 == null)
	{
		r7_n->ptr0000 = r0_n;
		vListInitialise((char *) &r7_n->ptr0000 + 0x04);
		vListInitialise((char *) &r7_n->ptr0000 + 0x0018);
		vListInitialise((char *) &r7_n->ptr0000 + 44);
		vListInitialise((char *) &r7_n->ptr0000 + 0x0040);
		vListInitialise((char *) &r7_n->ptr0000 + 0x0054);
		r7_n->ptr0068 = (char *) &r7_n->ptr0000 + 44;
		r7_n->ptr006C = (char *) &r7_n->ptr0000 + 0x0040;
	}
	if (r1 >= 0x01)
		r5_n = 0x01;
	r0_n->w0034 = 0x00;
	r0_n->dw002C = r5_n;
	r0_n->ptr0030 = r2;
	r0_n->ptr0000 = r0;
	vListInitialiseItem(&r0_n->dw0004);
	vListInitialiseItem(&r0_n->dw0018);
	uint32 r0_n = r0_n->dw002C;
	word32 r5_n = 0x02 - r5_n;
	if (r0_n > r7_n->dw0070)
		r7_n->dw0070 = r0_n;
	r0_n->dw0018 = r5_n;
	r0_n->ptr0010 = r0_n;
	r0_n->ptr0024 = r0_n;
	vListInsertEnd((char *) &r7_n->ptr0000 + 0x04 + r0_n * 0x14, &r0_n->dw0004);
}

// 00008EF0: FlagGroup bool vCoRoutineAddToDelayedList(Register Eq_n r0, Register (ptr32 Eq_n) r1)
bool vCoRoutineAddToDelayedList(Eq_n r0, struct Eq_n * r1)
{
	struct Eq_n * r4_n = globals->ptr8F28;
	up32 r5_n = (word32) r0 + r4_n->dw0074;
	uxListRemove(&r4_n->ptr0000->dw0004);
	up32 r3_n = r4_n->dw0074;
	struct Eq_n * r1_n = r4_n->ptr0000;
	r1_n->dw0004 = r5_n;
	bool Z_n = vListInsert(r4_n->ptr0068, &r1_n->dw0004);
	if (r1 == null)
		return Z_n;
	struct Eq_n * r1_n = r4_n->ptr0000;
	return vListInsert(r1, &r1_n->dw0004 + 0x05);
}

// 00008F2C: Register word32 vCoRoutineSchedule(Register (ptr32 Eq_n) r0, Register word32 r4, Register word32 r5, Register word32 r6, Register word32 r7, Register word32 r8, Register word32 lr, Register ptr32 cpsr, Register out ptr32 cpsrOut)
word32 vCoRoutineSchedule(struct Eq_n * r0, word32 r4, word32 r5, word32 r6, word32 r7, word32 r8, word32 lr, ptr32 cpsr, ptr32 & cpsrOut)
{
	struct Eq_n * r5_n = globals->ptr9088;
	while (r5_n->dw0054 != 0x00)
	{
		__msr(cpsr, 191);
		__isb_sy();
		__dsb_sy();
		struct Eq_n * r4_n = r5_n->ptr0060->ptr000C;
		uxListRemove((char *) r4_n + 0x0018);
		__msr(cpsr, 0x00);
		uxListRemove((char *) r4_n + 0x04);
		uint32 r3_n = r4_n->dw002C;
		r0 = (struct Eq_n *) ((char *) &r5_n->ptr0000 + 0x04 + r3_n * 0x14);
		if (r3_n > r5_n->dw0070)
			r5_n->dw0070 = r3_n;
		vListInsertEnd(r0, (char *) r4_n + 0x04);
	}
	MPU_xTaskGetTickCount(cpsr);
	up32 r3_n = r5_n->dw0074;
	word32 r0_n = r0 - r5_n->dw0078;
	word32 r8_n = globals->dw9090;
	r5_n->dw007C = r0_n;
l00008F94:
	while (r0_n != 0x00)
	{
		struct Eq_n * r2_n;
		++r3_n;
		r5_n->dw0074 = r3_n;
		--r0_n;
		r5_n->dw007C = r0_n;
		if (r3_n != 0x00)
			r2_n = r5_n->ptr0068;
		else
		{
			r2_n = r5_n->ptr006C;
			r5_n->ptr006C = r5_n->ptr0068;
			r5_n->ptr0068 = r2_n;
		}
		if (r2_n->dw0000 == 0x00)
			goto l00008F94;
		struct Eq_n * r4_n = r2_n->ptr000C->ptr000C;
		if (r3_n < r4_n->dw0004)
			goto l00008F94;
		do
		{
			__msr(cpsr, 191);
			__isb_sy();
			__dsb_sy();
			struct Eq_n * r6_n = &r4_n->dw0004;
			uxListRemove(r6_n);
			struct Eq_n * r0_n = &r4_n->dw0004 + 0x05;
			if (r4_n->dw0028 != 0x00)
				uxListRemove(r0_n);
			__msr(cpsr, 0x00);
			uint32 r3_n = r4_n->dw002C;
			struct Eq_n * r0_n = r8_n + r3_n * 0x14;
			if (r3_n > r5_n->dw0070)
				r5_n->dw0070 = r3_n;
			vListInsertEnd(r0_n, r6_n);
			struct Eq_n * r3_n = r5_n->ptr0068;
			if (r3_n->dw0000 == 0x00)
			{
				r3_n = r5_n->dw0074;
				break;
			}
			r4_n = r3_n->ptr000C->ptr000C;
			r3_n = r5_n->dw0074;
		} while (r4_n->dw0004 <= r3_n);
		r0_n = r5_n->dw007C;
	}
	uint32 r2_n;
	uint32 r1_n = r5_n->dw0070;
	r5_n->dw0078 = r3_n;
	ui32 r3_n = r1_n << 0x02;
	if (*((char *) &(r5_n + (r1_n * 0x14) / 0x0080)->ptr0000 + 0x04) == 0x00)
	{
		if (r1_n == 0x00)
		{
			cpsrOut = cpsr;
			return lr;
		}
		r3_n = r1_n - 0x01 << 0x02;
		r2_n = r1_n - 0x01;
		if (*((char *) &(r5_n + (r3_n + (r1_n - 0x01) << 0x02) / 0x0080)->ptr0000 + 0x04) == 0x00)
		{
			if (r1_n == 0x01)
			{
l00009046:
				r5_n->dw0070 = r2_n;
				cpsrOut = cpsr;
				return lr;
			}
			r3_n = r1_n - 0x02 << 0x02;
			r2_n = r1_n - 0x02;
			if (*((char *) &(r5_n + (r3_n + (r1_n - 0x02) << 0x02) / 0x0080)->ptr0000 + 0x04) == 0x00)
				goto l00009046;
		}
		r5_n->dw0070 = r2_n;
	}
	else
		r2_n = r1_n;
	struct Eq_n * r2_n;
	ui32 r3_n = r3_n + r2_n;
	struct Eq_n * r1_n = r5_n + (r3_n << 0x02) / 0x0080;
	struct Eq_n * r2_n = r1_n->ptr0008->ptr0004;
	struct Eq_n * r3_n = (r3_n << 0x02) + globals->dw908C;
	r1_n->ptr0008 = r2_n;
	r2_n = r2_n;
	if (r2_n == r3_n)
		r2_n = r2_n->ptr0004;
	<anonymous> ** r0_n = r2_n->ptr000C;
	if (r2_n == r3_n)
		r1_n->ptr0008 = r2_n;
	r5_n->ptr0000 = r0_n;
	word32 lr_n;
	word32 pc_n;
	ptr32 cpsr_n;
	(*r0_n)();
	cpsrOut = cpsr_n;
	return lr_n;
}

// 00009094: FlagGroup bool xCoRoutineRemoveFromEventList(Register (ptr32 Eq_n) r0, Register out ptr32 r0Out)
bool xCoRoutineRemoveFromEventList(struct Eq_n * r0, ptr32 & r0Out)
{
	struct Eq_n * r4_n = r0->ptr000C->ptr000C;
	struct Eq_n ** r5_n = globals->ptr90C0;
	uxListRemove((char *) r4_n + 0x0018);
	vListInsertEnd((char *) r5_n + 0x0054, (char *) r4_n + 0x0018);
	up32 r0_n = r4_n->dw002C;
	up32 r3_n = *((char *) *r5_n + 44);
	bool Z_n = SLICE(cond(r0_n - r3_n), bool, 2);
	r0Out = 0x01;
	return Z_n;
}

// 000090C4: void GPIOGetIntNumber(Register up32 r0)
void GPIOGetIntNumber(up32 r0)
{
	up32 r3_n = globals->dw9104;
	if (r0 == r3_n)
		return;
	if (r0 > r3_n)
	{
		up32 r3_n = globals->dw9108;
		if (r0 == r3_n)
			return;
		if (r0 != r3_n + 0x0001D000)
			;
	}
	else
	{
		if (r0 == 0x40004000)
			return;
		if (r0 != r3_n - 0x1000)
			;
	}
}

// 0000910C: void GPIODirModeSet(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2)
void GPIODirModeSet(struct Eq_n * r0, ui32 r1, ui32 r2)
{
	ui32 r3_n = r0->dw0400;
	if ((r2 & 0x01) != 0x00)
		r3_n |= r1;
	r0->dw0400 = r3_n & ~r1;
	ui32 r3_n = r0->dw0420;
	if (r2 << 0x001E < 0x00)
		r1 |= r3_n;
	r0->dw0420 = r3_n & ~r1;
}

// 00009134: void GPIODirModeGet(Register (ptr32 Eq_n) r0, Register word32 r1)
void GPIODirModeGet(struct Eq_n * r0, word32 r1)
{
	uint32 r1_n = (uint32) (byte) (0x01 << r1);
	word32 r2_n = r0->dw0420;
	up32 r4_n = (bool) C + (r0->dw0400 + r1_n);
}

// 0000915C: void GPIOIntTypeSet(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2)
void GPIOIntTypeSet(struct Eq_n * r0, ui32 r1, ui32 r2)
{
	ui32 r3_n = r0->dw0408;
	if ((r2 & 0x01) != 0x00)
		r3_n |= r1;
	r0->dw0408 = r3_n & ~r1;
	ui32 r3_n = r0->dw0404;
	if ((r2 & 0x02) != 0x00)
		r3_n |= r1;
	r0->dw0404 = r3_n & ~r1;
	ui32 r3_n = r0->dw040C;
	if (r2 << 0x001D < 0x00)
		r1 |= r3_n;
	r0->dw040C = r3_n & ~r1;
}

// 00009194: void GPIOIntTypeGet(Register (ptr32 Eq_n) r0, Register word32 r1)
void GPIOIntTypeGet(struct Eq_n * r0, word32 r1)
{
	uint32 r1_n = (uint32) (byte) (0x01 << r1);
	word32 r3_n = r0->dw0404;
	up32 r2_n = (bool) C + (r0->dw0408 + r1_n);
	word32 r0_n = r0->dw040C;
	up32 r3_n = (bool) (r2_n < 0x00) + (r3_n + r1_n);
}

// 000091C8: void GPIOPadConfigSet(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2, Register ui32 r3)
void GPIOPadConfigSet(struct Eq_n * r0, ui32 r1, ui32 r2, ui32 r3)
{
	ui32 r4_n = r0->dw0500;
	if ((r2 & 0x01) != 0x00)
		r4_n |= r1;
	r0->dw0500 = r4_n & ~r1;
	ui32 r4_n = r0->dw0504;
	if ((r2 & 0x02) != 0x00)
		r4_n |= r1;
	r0->dw0504 = r4_n & ~r1;
	ui32 r4_n = r0->dw0508;
	if ((r2 & 0x04) != 0x00)
		r4_n |= r1;
	r0->dw0508 = r4_n & ~r1;
	ui32 r2_n = r0->dw0518;
	if ((r2 & 0x08) != 0x00)
		r2_n |= r1;
	r0->dw0518 = r2_n & ~r1;
	ui32 r2_n = r0->dw050C;
	if (r3 << 0x001F < 0x00)
		r2_n |= r1;
	r0->dw050C = r2_n & ~r1;
	ui32 r2_n = r0->dw0510;
	if (r3 << 0x001E < 0x00)
		r2_n |= r1;
	r0->dw0510 = r2_n & ~r1;
	ui32 r2_n = r0->dw0514;
	if (r3 << 0x001D < 0x00)
		r2_n |= r1;
	r0->dw0514 = r2_n & ~r1;
	ui32 r3_n = r0->dw051C;
	if ((r3 & 0x08) != 0x00)
		r1 |= r3_n;
	r0->dw051C = r3_n & ~r1;
}

// 0000925C: void GPIOPadConfigGet(Register (ptr32 Eq_n) r0, Register word32 r1, Register (ptr32 word32) r2, Register (ptr32 word32) r3)
void GPIOPadConfigGet(struct Eq_n * r0, word32 r1, word32 * r2, word32 * r3)
{
	uint32 r1_n = (uint32) (byte) (0x01 << r1);
	word32 r4_n = r0->dw0504;
	up32 r5_n = (bool) C + (r0->dw0500 + r1_n);
	word32 r5_n = r0->dw0508;
	up32 r4_n = (bool) (r5_n < 0x00) + (r4_n + r1_n);
	word32 r4_n = r0->dw0518;
	up32 r5_n = (bool) (r4_n < 0x00) + (r5_n + r1_n);
	*r2 = 0x00;
	word32 r5_n = 0x00;
	word32 r4_n = r0->dw0510;
	uint32 r1_n = r1_n + r0->dw050C;
	word32 r6_n = r0->dw0514;
	if (r1_n != 0x00)
		r5_n = 0x01;
	word32 r2_n = r0->dw051C;
	if (r1_n == 0x00)
		r5_n = 0x00;
	uint32 r1_n = r1_n + r4_n + (r1_n < 0x00);
	uint32 r1_n = r1_n + r6_n + (r1_n < 0x00);
	*r3 = r5_n;
}

// 000092E0: void GPIOPinIntEnable(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinIntEnable(struct Eq_n * r0, ui32 r1)
{
	r0->dw0410 = r1 | r0->dw0410;
}

// 000092EC: void GPIOPinIntDisable(Register (ptr32 Eq_n) r0, Register word32 r1)
void GPIOPinIntDisable(struct Eq_n * r0, word32 r1)
{
	r0->dw0410 &= ~r1;
}

// 000092FC: void GPIOPinIntStatus(Register word32 r1)
void GPIOPinIntStatus(word32 r1)
{
	if (r1 != 0x00)
		;
}

// 0000930C: void GPIOPinIntClear(Register (ptr32 Eq_n) r0, Register word32 r1)
void GPIOPinIntClear(struct Eq_n * r0, word32 r1)
{
	r0->dw041C = r1;
}

// 00009314: void GPIOPortIntRegister(Register up32 r0, Register word32 r1)
void GPIOPortIntRegister(up32 r0, word32 r1)
{
	up32 r3_n = globals->dw93A8;
	if (r0 == r3_n)
	{
		IntRegister(0x12, r1);
		IntEnable(0x12);
	}
	else
	{
		if (r0 <= r3_n)
		{
			if (r0 == 0x40004000)
			{
				IntRegister(0x10, r1);
				IntEnable(0x10);
				return;
			}
			if (r0 == r3_n - 0x1000)
			{
				IntRegister(0x11, r1);
				IntEnable(0x11);
				return;
			}
		}
		else
		{
			up32 r3_n = globals->dw93AC;
			if (r0 == r3_n)
			{
				IntRegister(0x13, r1);
				IntEnable(0x13);
				return;
			}
			if (r0 == r3_n + 0x0001D000)
			{
				IntRegister(0x14, r1);
				IntEnable(0x14);
				return;
			}
		}
		IntRegister(~0x00, r1);
		IntEnable(~0x00);
	}
}

// 000093B0: void GPIOPortIntUnregister(Register up32 r0)
void GPIOPortIntUnregister(up32 r0)
{
	up32 r3_n = globals->dw9444;
	if (r0 == r3_n)
	{
		IntDisable(0x12);
		IntUnregister(0x12);
	}
	else
	{
		if (r0 <= r3_n)
		{
			if (r0 == 0x40004000)
			{
				IntDisable(0x10);
				IntUnregister(0x10);
				return;
			}
			if (r0 == r3_n - 0x1000)
			{
				IntDisable(0x11);
				IntUnregister(0x11);
				return;
			}
		}
		else
		{
			up32 r3_n = globals->dw9448;
			if (r0 == r3_n)
			{
				IntDisable(0x13);
				IntUnregister(0x13);
				return;
			}
			if (r0 == r3_n + 0x0001D000)
			{
				IntDisable(0x14);
				IntUnregister(0x14);
				return;
			}
		}
		IntDisable(~0x00);
		IntUnregister(~0x00);
	}
}

// 0000944C: void GPIOPinRead()
void GPIOPinRead()
{
}

// 00009454: void GPIOPinWrite(Register (arr word32) r0, Register ui32 r1, Register word32 r2)
void GPIOPinWrite(word32 r0[], ui32 r1, word32 r2)
{
	r0[r1] = r2;
}

// 0000945C: void GPIOPinTypeComparator(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinTypeComparator(struct Eq_n * r0, ui32 r1)
{
	ui32 r5_n = ~r1;
	r0->dw0400 &= r5_n;
	r0->dw0420 = r5_n & r0->dw0420;
	GPIOPadConfigSet(r0, r1, 0x01, 0x00);
}

// 00009480: void GPIOPinTypeI2C(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinTypeI2C(struct Eq_n * r0, ui32 r1)
{
	r0->dw0400 &= ~r1;
	r0->dw0420 = r1 | r0->dw0420;
	GPIOPadConfigSet(r0, r1, 0x01, 11);
}

// 000094A4: void GPIOPinTypeQEI(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinTypeQEI(struct Eq_n * r0, ui32 r1)
{
	r0->dw0400 &= ~r1;
	r0->dw0420 = r1 | r0->dw0420;
	GPIOPadConfigSet(r0, r1, 0x01, 0x0A);
}

// 000094C8: void GPIOPinTypeUART(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinTypeUART(struct Eq_n * r0, ui32 r1)
{
	r0->dw0400 &= ~r1;
	r0->dw0420 = r1 | r0->dw0420;
	GPIOPadConfigSet(r0, r1, 0x01, 0x08);
}

// 000094EC: void GPIOPinTypeTimer(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinTypeTimer(struct Eq_n * r0, ui32 r1)
{
	GPIOPinTypeUART(r0, r1);
}

// 000094F0: void GPIOPinTypeSSI(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinTypeSSI(struct Eq_n * r0, ui32 r1)
{
	GPIOPinTypeUART(r0, r1);
}

// 000094F4: void GPIOPinTypePWM(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinTypePWM(struct Eq_n * r0, ui32 r1)
{
	GPIOPinTypeUART(r0, r1);
}

// 000094F8: void IntDefaultHandler()
void IntDefaultHandler()
{
	while (true)
		;
}

// 000094FC: void IntMasterEnable()
void IntMasterEnable()
{
	CPUcpsie();
}

// 00009500: void IntMasterDisable()
void IntMasterDisable()
{
	CPUcpsid();
}

// 00009504: void IntRegister(Register ui32 r0, Register word32 r1)
void IntRegister(ui32 r0, word32 r1)
{
	word32 r4_n[] = globals->ptr9534;
	if (*globals->ptr9530 != r4_n)
	{
		word32 r3_n[] = r4_n;
		do
		{
			Mem21[r3_n + 0x00:word32] = Mem19[r3_n - r4_n + 0x00:word32];
			r3_n = (word32 (*)[]) (r3_n + 0x01);
		} while (r3_n != r4_n + 0x002E);
		*globals->ptr9530 = r4_n;
	}
	r4_n[r0] = r1;
}

// 00009538: void IntUnregister(Register ui32 r0)
void IntUnregister(ui32 r0)
{
	globals->ptr9544[r0] = globals->dw9548;
}

// 0000954C: void IntPriorityGroupingSet(Register ui32 r0)
void IntPriorityGroupingSet(ui32 r0)
{
	*globals->ptr9564 = globals->ptr9560[r0] | 0x05F80000 | 0x00020000;
}

// 00009568: void IntPriorityGroupingGet()
void IntPriorityGroupingGet()
{
	ui32 r3_n = 0x0700;
	word32 r0_n = 0x00;
	ui32 r1_n = *globals->ptr9588;
	word32 * r2_n = globals->ptr958C;
	while (r3_n != (r1_n & 0x0700))
	{
		++r0_n;
		if (r0_n == 0x08)
			return;
		++r2_n;
		r3_n = *r2_n;
	}
}

// 00009590: void IntPrioritySet(Register ui32 r0, Register ui32 r1)
void IntPrioritySet(ui32 r0, ui32 r1)
{
	ui32 * r4_n = (globals->ptr95B8 + (r0 & ~0x03))->ptr0020;
	ui32 r0_n = (r0 & 0x03) << 0x03;
	*r4_n = r1 << r0_n | *r4_n & ~(0xFF << r0_n);
}

// 000095BC: void IntPriorityGet()
void IntPriorityGet()
{
}

// 000095DC: void IntEnable(Register up32 r0)
void IntEnable(up32 r0)
{
	if (r0 == 0x04)
	{
		ui32 * r2_n = globals->ptr9634;
		*r2_n |= 0x00010000;
	}
	else if (r0 == 0x05)
	{
		ui32 * r2_n = globals->ptr9634;
		*r2_n |= 0x00020000;
	}
	else if (r0 == 0x06)
	{
		ui32 * r2_n = globals->ptr9634;
		*r2_n |= 0x00040000;
	}
	else if (r0 == 0x0F)
	{
		ui32 * r2_n = globals->ptr9630;
		*r2_n |= 0x02;
	}
	else if (r0 > 0x0F)
		*globals->ptr962C = 0x01 << r0 - 0x10;
}

// 00009638: void IntDisable(Register up32 r0)
void IntDisable(up32 r0)
{
	if (r0 == 0x04)
	{
		ui32 * r2_n = globals->ptr9690;
		*r2_n &= ~0x00010000;
	}
	else if (r0 == 0x05)
	{
		ui32 * r2_n = globals->ptr9690;
		*r2_n &= ~0x00020000;
	}
	else if (r0 == 0x06)
	{
		ui32 * r2_n = globals->ptr9690;
		*r2_n &= ~0x00040000;
	}
	else if (r0 == 0x0F)
	{
		ui32 * r2_n = globals->ptr968C;
		*r2_n &= ~0x02;
	}
	else if (r0 > 0x0F)
		*globals->ptr9688 = 0x01 << r0 - 0x10;
}

// 00009694: void OSRAMDelay(Register word32 r0)
void OSRAMDelay(word32 r0)
{
	do
		--r0;
	while (r0 != 0x00);
}

// 0000969C: void OSRAMWriteFirst(Register ui32 r0)
void OSRAMWriteFirst(ui32 r0)
{
	struct Eq_n * r4_n = globals->ptr96C0;
	I2CMasterSlaveAddrSet(r4_n, 0x3D, 0x00);
	I2CMasterDataPut(r4_n, r0);
	I2CMasterControl(r4_n, 0x03);
}

// 000096C4: void OSRAMWriteArray(Register (ptr32 byte) r0, Register int32 r1)
void OSRAMWriteArray(byte * r0, int32 r1)
{
	if (r1 == 0x00)
		return;
	byte * r5_n;
	word32 * r7_n = globals->ptr96FC;
	struct Eq_n * r4_n = globals->ptr9700;
	byte * r6_n = r0 + r1;
	do
	{
		do
			;
		while (I2CMasterIntStatus(r4_n, 0x00) == 0x00);
		OSRAMDelay(*r7_n);
		I2CMasterDataPut(r4_n, (word32) *r5_n);
		I2CMasterControl(r4_n, 0x01);
		++r5_n;
	} while (r6_n != r5_n);
}

// 00009704: void OSRAMWriteByte(Register ui32 r0)
void OSRAMWriteByte(ui32 r0)
{
	do
		;
	while (I2CMasterIntStatus(globals->ptr9730, 0x00) == 0x00);
	OSRAMDelay(*globals->ptr9734);
	I2CMasterDataPut(globals->ptr9730, r0);
	struct Eq_n * r0_n = globals->ptr9730;
	I2CMasterControl(r0_n, 0x01);
}

// 00009738: void OSRAMWriteFinal(Register ui32 r0)
void OSRAMWriteFinal(ui32 r0)
{
	struct Eq_n * r4_n = globals->ptr9778;
	do
		;
	while (I2CMasterIntStatus(r4_n, 0x00) == 0x00);
	word32 * r5_n = globals->ptr977C;
	struct Eq_n * r4_n = globals->ptr9778;
	OSRAMDelay(*r5_n);
	I2CMasterDataPut(r4_n, r0);
	I2CMasterControl(r4_n, 0x05);
	do
		;
	while (I2CMasterIntStatus(r4_n, 0x00) == 0x00);
	word32 r0_n = *r5_n;
	OSRAMDelay(r0_n);
}

// 00009780: void OSRAMClear()
void OSRAMClear()
{
	OSRAMWriteFirst(0x80);
	OSRAMWriteArray(globals->ptr97C4, 0x06);
	ui32 r4_n;
	for (r4_n = 0x5F; r4_n != 0x00; --r4_n)
		OSRAMWriteByte(0x00);
	OSRAMWriteFinal(r4_n);
	OSRAMWriteFirst(0x80);
	OSRAMWriteArray(globals->ptr97C8, 0x06);
	ui32 r4_n;
	for (r4_n = 0x5F; r4_n != 0x00; --r4_n)
		OSRAMWriteByte(0x00);
	OSRAMWriteFinal(r4_n);
}

// 000097CC: void OSRAMStringDraw(Register (ptr32 byte) r0, Register uint32 r1, Register ui32 r2)
void OSRAMStringDraw(byte * r0, uint32 r1, ui32 r2)
{
	OSRAMWriteFirst(0x80);
	uint32 r4_n = r1;
	byte * r5_n = r0;
	OSRAMWriteByte(177);
	OSRAMWriteByte(0x80);
	OSRAMWriteByte(r1 + 0x24 & 0x0F);
	OSRAMWriteByte(0x80);
	OSRAMWriteByte((uint32) SLICE(r1 + 0x24, ui4, 4) | 0x10);
	OSRAMWriteByte(0x40);
	ui32 r3_n = (word32) *r0;
	if (r3_n == 0x00)
		return;
	word32 r6_n = globals->dw9878;
	if (r1 <= 0x5A)
	{
		do
		{
			OSRAMWriteArray(r6_n + (r3_n - 0x20) * 0x05, 0x05);
			if (r4_n == 0x5A)
			{
l00009846:
				OSRAMWriteFinal(0x00);
				return;
			}
			++r5_n;
			r4_n += 0x06;
			if ((word32) *r5_n == 0x00)
				goto l00009846;
			OSRAMWriteByte(0x00);
			r3_n = (word32) *r5_n;
			if (r3_n == 0x00)
				return;
		} while (r4_n <= 0x5A);
	}
	int32 r4_n = 0x5F - r4_n;
	OSRAMWriteArray(r6_n + (r3_n - 0x20) * 0x05, r4_n);
	Eq_n r3_n = (word32) *r5_n;
	ui32 r0_n = (word32) (r3_n - 0x20 + (r3_n - 0x20 << 0x02) + globals->dw987C + r4_n)->b0010;
	OSRAMWriteFinal(r0_n);
}

// 00009880: void OSRAMImageDraw(Register (ptr32 byte) r0, Register word32 r1, Register word32 r2, Register word32 r3, Stack word32 dwArg00)
void OSRAMImageDraw(byte * r0, word32 r1, word32 r2, word32 r3, word32 dwArg00)
{
	if (dwArg00 != 0x00)
	{
		byte * r5_n = r0;
		word32 r4_n;
		uint32 r8_n = (uint32) SLICE(r1 + 0x24, ui4, 4);
		word32 r6_n = dwArg00 + r2;
		ui32 r7_n = r1 + 0x24 & 0x0F;
		do
		{
			OSRAMWriteFirst(0x80);
			OSRAMWriteByte(0xB0);
			OSRAMWriteByte(0x80);
			OSRAMWriteByte(r7_n);
			OSRAMWriteByte(0x80);
			OSRAMWriteByte(r8_n | 0x10);
			OSRAMWriteByte(0x40);
			OSRAMWriteArray(r5_n, r3 + ~0x00);
			r5_n += r3;
			OSRAMWriteFinal((word32) *(r5_n - 0x01));
			++r4_n;
		} while (r6_n != r4_n);
	}
}

// 000098F0: void OSRAMInit(Register word32 r0)
void OSRAMInit(word32 r0)
{
	SysCtlPeripheralEnable(0x10001000);
	SysCtlPeripheralEnable(globals->dw9960);
	GPIOPinTypeI2C(globals->ptr9964, 0x0C);
	I2CMasterInit(globals->ptr9968, r0);
	word32 r7_n = globals->dw9970;
	*globals->ptr996C = 0x01;
	ui32 r6_n = 227;
	int32 r4_n = 0x04;
	ui32 r0_n = 0x80;
	up32 r5_n = 0x00;
	while (true)
	{
		OSRAMWriteFirst(r0_n);
		OSRAMWriteArray(r5_n + 0x02 + (r7_n + 0x01EC), r4_n - 0x02);
		OSRAMWriteFinal(r6_n);
		r5_n += r4_n + 0x01;
		struct Eq_n * r3_n = r7_n + r5_n;
		if (r5_n > 0x70)
			break;
		r4_n = (word32) r3_n->b01EC;
		r0_n = (word32) r3_n->b01ED;
		r6_n = (word32) (r3_n + r4_n / 0x01EE)->b01EC;
	}
	OSRAMClear();
}

// 00009974: void OSRAMDisplayOn()
void OSRAMDisplayOn()
{
	word32 r7_n = globals->dw99BC;
	ui32 r6_n = 227;
	int32 r4_n = 0x04;
	ui32 r0_n = 0x80;
	up32 r5_n = 0x00;
	while (true)
	{
		OSRAMWriteFirst(r0_n);
		OSRAMWriteArray(r5_n + 0x02 + (r7_n + 0x01EC), r4_n - 0x02);
		OSRAMWriteFinal(r6_n);
		r5_n += r4_n + 0x01;
		struct Eq_n * r3_n = r7_n + r5_n;
		if (r5_n > 0x70)
			break;
		r4_n = (word32) r3_n->b01EC;
		r0_n = (word32) r3_n->b01ED;
		r6_n = (word32) (r3_n + r4_n / 0x01EE)->b01EC;
	}
}

// 000099C0: void OSRAMDisplayOff()
void OSRAMDisplayOff()
{
	OSRAMWriteFirst(0x80);
	OSRAMWriteByte(0xAE);
	OSRAMWriteByte(0x80);
	OSRAMWriteByte(0xAD);
	OSRAMWriteByte(0x80);
	OSRAMWriteFinal(0x8A);
}

// 000099E8: void SSIConfig(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2, Register uint32 r3, Stack ui32 dwArg00)
void SSIConfig(struct Eq_n * r0, ui32 r1, ui32 r2, uint32 r3, ui32 dwArg00)
{
	ui32 r7_n = r2;
	uint32 r0_n = SysCtlClockGet();
	if (r2 != 0x02)
	{
		if (r2 != 0x00)
			r7_n = 0x04;
	}
	else
		r7_n = 0x0C;
	r0->dw0004 = r7_n;
	uint32 r3_n = r0_n /u r3;
	uint32 r4_n = 0x00;
	do
	{
		r4_n += 0x02;
		uint32 r2_n = r3_n /u r4_n;
	} while (r2_n > 0x0100);
	r0->dw0010 = r4_n;
	r0->dw0000 = dwArg00 - 0x01 | (r1 & 0x30 | r1 << 0x06) | r2_n - 0x01 << 0x08;
}

// 00009A34: void SSIEnable(Register (ptr32 Eq_n) r0)
void SSIEnable(struct Eq_n * r0)
{
	r0->dw0004 |= 0x02;
}

// 00009A40: void SSIDisable(Register (ptr32 Eq_n) r0)
void SSIDisable(struct Eq_n * r0)
{
	r0->dw0004 &= ~0x02;
}

// 00009A4C: void SSIIntRegister(Register word32 r1)
void SSIIntRegister(word32 r1)
{
	IntRegister(0x17, r1);
	IntEnable(0x17);
}

// 00009A60: void SSIIntUnregister()
void SSIIntUnregister()
{
	IntDisable(0x17);
	IntUnregister(0x17);
}

// 00009A74: void SSIIntEnable(Register (ptr32 Eq_n) r0, Register ui32 r1)
void SSIIntEnable(struct Eq_n * r0, ui32 r1)
{
	r0->dw0014 = r1 | r0->dw0014;
}

// 00009A7C: void SSIIntDisable(Register (ptr32 Eq_n) r0, Register word32 r1)
void SSIIntDisable(struct Eq_n * r0, word32 r1)
{
	r0->dw0014 &= ~r1;
}

// 00009A88: void SSIIntStatus(Register word32 r1)
void SSIIntStatus(word32 r1)
{
	if (r1 != 0x00)
		;
}

// 00009A94: void SSIIntClear(Register (ptr32 Eq_n) r0, Register word32 r1)
void SSIIntClear(struct Eq_n * r0, word32 r1)
{
	r0->dw0020 = r1;
}

// 00009A98: void SSIDataPut(Register (ptr32 Eq_n) r0, Register ui32 r1)
void SSIDataPut(struct Eq_n * r0, ui32 r1)
{
	do
		;
	while (r0->dw000C << 0x001E >= 0x00);
	r0->dw0008 = r1;
}

// 00009AA8: void SSIDataNonBlockingPut(Register (ptr32 Eq_n) r0, Register word32 r1)
void SSIDataNonBlockingPut(struct Eq_n * r0, word32 r1)
{
	if ((r0->dw000C & 0x02) != 0x00)
		r0->dw0008 = r1;
}

// 00009AB8: void SSIDataGet(Register (ptr32 Eq_n) r0, Register (ptr32 ui32) r1)
void SSIDataGet(struct Eq_n * r0, ui32 * r1)
{
	do
		;
	while (r0->dw000C << 0x001D >= 0x00);
	*r1 = r0->dw0008;
}

// 00009AC8: void SSIDataNonBlockingGet(Register (ptr32 Eq_n) r0, Register (ptr32 ui32) r1)
void SSIDataNonBlockingGet(struct Eq_n * r0, ui32 * r1)
{
	ui32 r3_n = r0->dw000C;
	ui32 r3_n = r3_n & 0x04;
	if ((r3_n & 0x04) != 0x00)
		r3_n = r0->dw0008;
	*r1 = r3_n;
}

// 00009ADC: void SysCtlSRAMSizeGet()
void SysCtlSRAMSizeGet()
{
}

// 00009AF4: void SysCtlFlashSizeGet()
void SysCtlFlashSizeGet()
{
}

// 00009B0C: void SysCtlPinPresent(Register word32 r0)
void SysCtlPinPresent(word32 r0)
{
	(bool) C + (*globals->ptr9B1C + r0) == 0x00;
}

// 00009B20: void SysCtlPeripheralPresent(Register uint32 r0)
void SysCtlPeripheralPresent(uint32 r0)
{
	(r0 & ~0xF0000000) + *(globals->ptr9B38)[r0 >> 0x001C] + (r0 >> 0x001C < 0x00) == 0x00;
}

// 00009B3C: void SysCtlPeripheralReset(Register uint32 r0)
void SysCtlPeripheralReset(uint32 r0)
{
	ui32 * r2_n = (globals->ptr9B78 + ((r0 >> 0x001C) << 0x02))->ptr0010;
	*r2_n = r0 & ~0xF0000000 | *r2_n;
	up32 dwLoc0C_n = 0x00;
	if (false)
	{
		do
			++dwLoc0C_n;
		while (dwLoc0C_n <= 0x0F);
	}
	*r2_n &= ~r0;
}

// 00009B7C: void SysCtlPeripheralEnable(Register uint32 r0)
void SysCtlPeripheralEnable(uint32 r0)
{
	ui32 * r3_n = (globals->ptr9B94 + ((r0 >> 0x001C) << 0x02))->ptr001C;
	*r3_n = r0 & ~0xF0000000 | *r3_n;
}

// 00009B98: void SysCtlPeripheralDisable(Register uint32 r0)
void SysCtlPeripheralDisable(uint32 r0)
{
	ui32 * r2_n = (globals->ptr9BB0 + ((r0 >> 0x001C) << 0x02))->ptr001C;
	*r2_n &= ~(r0 & ~0xF0000000);
}

// 00009BB4: void SysCtlPeripheralSleepEnable(Register uint32 r0)
void SysCtlPeripheralSleepEnable(uint32 r0)
{
	ui32 * r3_n = (globals->ptr9BCC + ((r0 >> 0x001C) << 0x02))->ptr0028;
	*r3_n = r0 & ~0xF0000000 | *r3_n;
}

// 00009BD0: void SysCtlPeripheralSleepDisable(Register uint32 r0)
void SysCtlPeripheralSleepDisable(uint32 r0)
{
	ui32 * r2_n = (globals->ptr9BE8 + ((r0 >> 0x001C) << 0x02))->ptr0028;
	*r2_n &= ~(r0 & ~0xF0000000);
}

// 00009BEC: void SysCtlPeripheralDeepSleepEnable(Register uint32 r0)
void SysCtlPeripheralDeepSleepEnable(uint32 r0)
{
	ui32 * r3_n = (globals->ptr9C04 + ((r0 >> 0x001C) << 0x02))->ptr0034;
	*r3_n = r0 & ~0xF0000000 | *r3_n;
}

// 00009C08: void SysCtlPeripheralDeepSleepDisable(Register uint32 r0)
void SysCtlPeripheralDeepSleepDisable(uint32 r0)
{
	ui32 * r2_n = (globals->ptr9C20 + ((r0 >> 0x001C) << 0x02))->ptr0034;
	*r2_n &= ~(r0 & ~0xF0000000);
}

// 00009C24: void SysCtlPeripheralClockGating(Register word32 r0)
void SysCtlPeripheralClockGating(word32 r0)
{
	ui32 * r2_n = globals->ptr9C3C;
	ui32 r3_n = *r2_n;
	if (r0 != 0x00)
		*r2_n = r3_n | 0x08000000;
	else
		*r2_n = r3_n & ~0x08000000;
}

// 00009C40: void SysCtlIntRegister(Register word32 r0)
void SysCtlIntRegister(word32 r0)
{
	IntRegister(44, r0);
	IntEnable(44);
}

// 00009C54: void SysCtlIntUnregister()
void SysCtlIntUnregister()
{
	IntDisable(44);
	IntUnregister(44);
}

// 00009C68: void SysCtlIntEnable(Register ui32 r0)
void SysCtlIntEnable(ui32 r0)
{
	ui32 * r2_n = globals->ptr9C74;
	*r2_n = r0 | *r2_n;
}

// 00009C78: void SysCtlIntDisable(Register word32 r0)
void SysCtlIntDisable(word32 r0)
{
	ui32 * r2_n = globals->ptr9C84;
	*r2_n &= ~r0;
}

// 00009C88: void SysCtlIntClear(Register word32 r0)
void SysCtlIntClear(word32 r0)
{
	*globals->ptr9C90 = r0;
}

// 00009C94: void SysCtlIntStatus(Register word32 r0)
void SysCtlIntStatus(word32 r0)
{
	if (r0 != 0x00)
		;
}

// 00009CAC: void SysCtlLDOSet(Register word32 r0)
void SysCtlLDOSet(word32 r0)
{
	*globals->ptr9CB4 = r0;
}

// 00009CB8: void SysCtlLDOGet()
void SysCtlLDOGet()
{
}

// 00009CC4: void SysCtlLDOConfigSet(Register word32 r0)
void SysCtlLDOConfigSet(word32 r0)
{
	*globals->ptr9CCC = r0;
}

// 00009CD0: void SysCtlReset()
void SysCtlReset()
{
	*globals->ptr9CD8 = globals->dw9CDC;
	while (true)
		;
}

// 00009CE0: void SysCtlSleep()
void SysCtlSleep()
{
	CPUwfi();
}

// 00009CE4: void SysCtlDeepSleep()
void SysCtlDeepSleep()
{
	ui32 * r4_n = globals->ptr9D00;
	*r4_n |= 0x04;
	CPUwfi();
	*r4_n &= ~0x04;
}

// 00009D04: void SysCtlResetCauseGet()
void SysCtlResetCauseGet()
{
}

// 00009D10: void SysCtlResetCauseClear(Register word32 r0)
void SysCtlResetCauseClear(word32 r0)
{
	ui32 * r2_n = globals->ptr9D1C;
	*r2_n &= ~r0;
}

// 00009D20: void SysCtlBrownOutConfigSet(Register ui32 r0, Register ui32 r1)
void SysCtlBrownOutConfigSet(ui32 r0, ui32 r1)
{
	*globals->ptr9D2C = r0 | r1 << 0x02;
}

// 00009D30: void SysCtlClockSet(Register ui32 r0)
void SysCtlClockSet(ui32 r0)
{
	ui32 * r4_n = globals->ptr9DE0;
	ui32 r3_n = *r4_n;
	word32 * r5_n = globals->ptr9DE8;
	ui32 r2_n = r0 & 0x33F0 | (globals->dw9DE4 & r3_n | 0x0800) & (r0 | ~0x03);
	*r4_n = r3_n & ~0x00400000 | 0x0800;
	*r5_n = 0x40;
	*r4_n = r2_n;
	up32 dwLoc14_n = 0x00;
	if (false)
	{
		do
			++dwLoc14_n;
		while (dwLoc14_n <= 0x0F);
	}
	ui32 r2_n = r2_n & ~0x03 | r0 & 0x03;
	*globals->ptr9DE0 = r2_n;
	ui32 r1_n = r0 & 0x07C00000 | r2_n & ~0x07C00000;
	if (r0 << 0x0014 >= 0x00)
	{
		word32 dwLoc14_n = 0x8000;
		if (0x8000 != 0x00)
		{
			ui32 * r2_n = globals->ptr9DEC;
			if (*r2_n << 0x0019 >= 0x00)
			{
				do
					--dwLoc14_n;
				while (dwLoc14_n != 0x00 && *r2_n << 0x0019 >= 0x00);
			}
		}
		r1_n &= ~0x0800;
	}
	*globals->ptr9DE0 = r1_n;
	up32 dwLoc14_n = 0x00;
	if (false)
	{
		do
			++dwLoc14_n;
		while (dwLoc14_n <= 0x0F);
	}
}

// 00009DF0: Register uint32 SysCtlClockGet()
uint32 SysCtlClockGet()
{
	uint32 r0_n;
	ui32 r3_n = *globals->ptr9E54;
	if ((r3_n & 0x30) != 0x10)
	{
		if ((r3_n & 0x30) != 0x20)
		{
			if ((r3_n & 0x30) != 0x00)
			{
				r0_n = 0x00;
				return r0_n;
			}
			r0_n = (globals->ptr9E58 + ((uint32) SLICE(r3_n, ui4, 6) << 0x02))->dw0030;
		}
		else
			r0_n = globals->dw9E60;
	}
	else
		r0_n = globals->dw9E64;
	if (r3_n << 0x0014 >= 0x00)
	{
		ui32 r2_n = *globals->ptr9E5C;
		r0_n = r0_n * ((uint32) SLICE(r2_n, ui9, 5) + 0x02) /u ((r2_n & 0x1F) + 0x02);
		if (r2_n << 0x0011 < 0x00)
			r0_n >>= 0x01;
		if (r2_n << 0x0010 < 0x00)
			r0_n >>= 0x02;
	}
	if (r3_n << 0x09 >= 0x00)
		return r0_n;
	return r0_n /u ((uint32) SLICE(r3_n, ui4, 23) + 0x01);
}

// 00009E68: void SysCtlPWMClockSet(Register ui32 r0)
void SysCtlPWMClockSet(ui32 r0)
{
	ui32 * r2_n = globals->ptr9E78;
	*r2_n = r0 | *r2_n & ~0x001E0000;
}

// 00009E7C: void SysCtlPWMClockGet()
void SysCtlPWMClockGet()
{
}

// 00009E8C: void SysCtlADCSpeedSet(Register ui32 r0)
void SysCtlADCSpeedSet(ui32 r0)
{
	ui32 * r4_n = globals->ptr9EB8;
	ui32 * r1_n = globals->ptr9EBC;
	ui32 * r2_n = globals->ptr9EC0;
	*r4_n = *r4_n & ~0x0F00 | r0;
	*r1_n = *r1_n & ~0x0F00 | r0;
	*r2_n = r0 | *r2_n & ~0x0F00;
}

// 00009EC4: void SysCtlADCSpeedGet()
void SysCtlADCSpeedGet()
{
}

// 00009ED4: void SysCtlIOSCVerificationSet(Register word32 r0)
void SysCtlIOSCVerificationSet(word32 r0)
{
	ui32 * r2_n = globals->ptr9EEC;
	ui32 r3_n = *r2_n;
	if (r0 != 0x00)
		*r2_n = r3_n | 0x08;
	else
		*r2_n = r3_n & ~0x08;
}

// 00009EF0: void SysCtlMOSCVerificationSet(Register word32 r0)
void SysCtlMOSCVerificationSet(word32 r0)
{
	ui32 * r2_n = globals->ptr9F08;
	ui32 r3_n = *r2_n;
	if (r0 != 0x00)
		*r2_n = r3_n | 0x04;
	else
		*r2_n = r3_n & ~0x04;
}

// 00009F0C: void SysCtlPLLVerificationSet(Register word32 r0)
void SysCtlPLLVerificationSet(word32 r0)
{
	ui32 * r2_n = globals->ptr9F24;
	ui32 r3_n = *r2_n;
	if (r0 != 0x00)
		*r2_n = r3_n | 0x0400;
	else
		*r2_n = r3_n & ~0x0400;
}

// 00009F28: void SysCtlClkVerificationClear()
void SysCtlClkVerificationClear()
{
	word32 * r3_n = globals->ptr9F34;
	*r3_n = 0x01;
	*r3_n = 0x00;
}

// 00009F38: void UARTParityModeSet(Register (ptr32 Eq_n) r0, Register ui32 r1)
void UARTParityModeSet(struct Eq_n * r0, ui32 r1)
{
	r0->dw002C = r1 | r0->dw002C & ~0x86;
}

// 00009F44: void UARTParityModeGet()
void UARTParityModeGet()
{
}

// 00009F4C: void UARTConfigSet(Register (ptr32 Eq_n) r0, Register uint32 r1, Register ui32 r2)
void UARTConfigSet(struct Eq_n * r0, uint32 r1, ui32 r2)
{
	do
	{
		ui32 r4_n = r0->dw0018;
	} while ((r4_n & 0x08) != 0x00);
	r0->dw002C &= ~0x10;
	r0->dw0030 = r0->dw0030 & ~0x0300 & ~0x01;
	uint32 r0_n = SysCtlClockGet();
	uint32 r2_n = r0_n /u (r1 << 0x04);
	r0->dw0024 = r2_n;
	r0->dw0028 = (r0_n - (r1 << 0x04) * r2_n << 0x03) /u r1 + 0x01 >> 0x01;
	r0->dw002C = r2;
	r0->dw0018 = r4_n & 0x08;
	r0->dw002C |= 0x10;
	r0->dw0030 = r0->dw0030 | 0x0300 | 0x01;
}

// 00009FA8: void UARTConfigGet(Register (ptr32 Eq_n) r0, Register (ptr32 uint32) r1, Register (ptr32 ui32) r2)
void UARTConfigGet(struct Eq_n * r0, uint32 * r1, ui32 * r2)
{
	*r1 = (SysCtlClockGet() << 0x02) /u (r0->dw0028 + (r0->dw0024 << 0x06));
	*r2 = r0->dw002C & 0xEE;
}

// 00009FD4: void UARTEnable(Register (ptr32 Eq_n) r0)
void UARTEnable(struct Eq_n * r0)
{
	r0->dw002C |= 0x10;
	r0->dw0030 = r0->dw0030 | 0x0300 | 0x01;
}

// 00009FEC: void UARTDisable(Register (ptr32 Eq_n) r0)
void UARTDisable(struct Eq_n * r0)
{
	do
		;
	while (r0->dw0018 << 0x001C < 0x00);
	r0->dw002C &= ~0x10;
	r0->dw0030 = r0->dw0030 & ~0x0300 & ~0x01;
}

// 0000A00C: void UARTCharsAvail()
void UARTCharsAvail()
{
}

// 0000A018: void UARTSpaceAvail()
void UARTSpaceAvail()
{
}

// 0000A024: void UARTCharNonBlockingGet(Register (ptr32 Eq_n) r0)
void UARTCharNonBlockingGet(struct Eq_n * r0)
{
	r0->dw0018 << 0x001B < 0x00;
}

// 0000A034: void UARTCharGet(Register (ptr32 Eq_n) r0)
void UARTCharGet(struct Eq_n * r0)
{
	do
		;
	while (r0->dw0018 << 0x001B < 0x00);
}

// 0000A044: void UARTCharNonBlockingPut(Register (ptr32 Eq_n) r0, Register word32 r1)
void UARTCharNonBlockingPut(struct Eq_n * r0, word32 r1)
{
	if (r0->dw0018 << 0x001A >= 0x00)
		r0->dw0000 = r1;
}

// 0000A054: void UARTCharPut(Register (ptr32 Eq_n) r0, Register word32 r1)
void UARTCharPut(struct Eq_n * r0, word32 r1)
{
	do
		;
	while (r0->dw0018 << 0x001A < 0x00);
	r0->dw0000 = r1;
}

// 0000A064: void UARTBreakCtl(Register (ptr32 Eq_n) r0, Register word32 r1)
void UARTBreakCtl(struct Eq_n * r0, word32 r1)
{
	ui32 r3_n = r0->dw002C;
	if (r1 != 0x00)
		r0->dw002C = r3_n | 0x01;
	else
		r0->dw002C = r3_n & ~0x01;
}

// 0000A078: void UARTIntRegister(Register word32 r0, Register word32 r1)
void UARTIntRegister(word32 r0, word32 r1)
{
	r0 != globals->dwA094;
	IntRegister(22, r1);
	IntEnable(22);
}

// 0000A098: void UARTIntUnregister(Register word32 r0)
void UARTIntUnregister(word32 r0)
{
	r0 != globals->dwA0B4;
	IntDisable(22);
	IntUnregister(22);
}

// 0000A0B8: void UARTIntEnable(Register (ptr32 Eq_n) r0, Register ui32 r1)
void UARTIntEnable(struct Eq_n * r0, ui32 r1)
{
	r0->dw0038 = r1 | r0->dw0038;
}

// 0000A0C0: void UARTIntDisable(Register (ptr32 Eq_n) r0, Register word32 r1)
void UARTIntDisable(struct Eq_n * r0, word32 r1)
{
	r0->dw0038 &= ~r1;
}

// 0000A0CC: Register (ptr32 Eq_n) UARTIntStatus(Register (ptr32 Eq_n) r0, Register word32 r1)
struct Eq_n * UARTIntStatus(struct Eq_n * r0, word32 r1)
{
	if (r1 != 0x00)
		return r0->ptr0040;
	return r0->ptr003C;
}

// 0000A0D8: void UARTIntClear(Register (ptr32 Eq_n) r0, Register Eq_n r1)
void UARTIntClear(struct Eq_n * r0, Eq_n r1)
{
	r0->t0044 = r1;
}

// 0000A0DC: void CPUcpsie()
void CPUcpsie()
{
	__cps();
}

// 0000A0E4: void CPUcpsid()
void CPUcpsid()
{
	__cps();
}

// 0000A0EC: void CPUwfi()
void CPUwfi()
{
	__wait_for_interrupt();
}

// 0000A0F4: void I2CMasterInit(Register (ptr32 Eq_n) r0, Register word32 r1)
void I2CMasterInit(struct Eq_n * r0, word32 r1)
{
	r0->dw0020 |= 0x10;
	uint32 r0_n = SysCtlClockGet();
	uint32 r3_n = globals->dwA120;
	uint32 r2_n = globals->dwA124;
	if (r1 == 0x01)
		r3_n = r2_n;
	r0->dw000C = (r0_n - 0x01 + r3_n) /u r3_n - 0x01;
}

// 0000A128: void I2CSlaveInit(Register (ptr32 Eq_n) r0, Register word32 r1)
void I2CSlaveInit(struct Eq_n * r0, word32 r1)
{
	*(r0 - 0x07E0) |= 0x20;
	r0->dw0004 = 0x01;
	r0->dw0000 = r1;
}

// 0000A140: void I2CMasterEnable(Register (ptr32 Eq_n) r0)
void I2CMasterEnable(struct Eq_n * r0)
{
	r0->dw0020 |= 0x10;
}

// 0000A14C: void I2CSlaveEnable(Register (ptr32 Eq_n) r0)
void I2CSlaveEnable(struct Eq_n * r0)
{
	*(r0 - 0x07E0) |= 0x20;
	r0->dw0004 = 0x01;
}

// 0000A160: void I2CMasterDisable(Register (ptr32 Eq_n) r0)
void I2CMasterDisable(struct Eq_n * r0)
{
	r0->dw0020 &= ~0x10;
}

// 0000A16C: void I2CSlaveDisable(Register (ptr32 Eq_n) r0)
void I2CSlaveDisable(struct Eq_n * r0)
{
	r0->dw0004 = 0x00;
	*(r0 - 0x07E0) &= ~0x20;
}

// 0000A180: void I2CIntRegister(Register word32 r1)
void I2CIntRegister(word32 r1)
{
	IntRegister(0x18, r1);
	IntEnable(0x18);
}

// 0000A194: void I2CIntUnregister()
void I2CIntUnregister()
{
	IntDisable(0x18);
	IntUnregister(0x18);
}

// 0000A1A8: void I2CMasterIntEnable(Register (ptr32 Eq_n) r0)
void I2CMasterIntEnable(struct Eq_n * r0)
{
	r0->dw0010 = 0x01;
}

// 0000A1B0: void I2CSlaveIntEnable(Register (ptr32 Eq_n) r0)
void I2CSlaveIntEnable(struct Eq_n * r0)
{
	r0->dw000C = 0x01;
}

// 0000A1B8: void I2CMasterIntDisable(Register (ptr32 Eq_n) r0)
void I2CMasterIntDisable(struct Eq_n * r0)
{
	r0->dw0010 = 0x00;
}

// 0000A1C0: void I2CSlaveIntDisable(Register (ptr32 Eq_n) r0)
void I2CSlaveIntDisable(struct Eq_n * r0)
{
	r0->dw000C = 0x00;
}

// 0000A1C8: Register (ptr32 Eq_n) I2CMasterIntStatus(Register (ptr32 Eq_n) r0, Register word32 r1)
struct Eq_n * I2CMasterIntStatus(struct Eq_n * r0, word32 r1)
{
	if (r1 != 0x00)
	{
		struct Eq_n * r0_n = r0->ptr0018;
		struct Eq_n * r0_n = r0_n;
		if (r0_n != null)
			r0_n = &globals->dw0001;
		return r0_n;
	}
	else
	{
		struct Eq_n * r0_n = r0->ptr0014;
		struct Eq_n * r0_n = r0_n;
		if (r0_n != null)
			r0_n = &globals->dw0001;
		return r0_n;
	}
}

// 0000A1E0: void I2CSlaveIntStatus(Register (ptr32 Eq_n) r0, Register word32 r1)
void I2CSlaveIntStatus(struct Eq_n * r0, word32 r1)
{
	if (r1 != 0x00)
		r0->dw0014 == 0x00;
	else
		r0->dw0010 == 0x00;
}

// 0000A1F8: void I2CMasterIntClear(Register (ptr32 Eq_n) r0)
void I2CMasterIntClear(struct Eq_n * r0)
{
	r0->dw001C = 0x01;
	r0->dw0018 = 0x01;
}

// 0000A200: void I2CSlaveIntClear(Register (ptr32 Eq_n) r0)
void I2CSlaveIntClear(struct Eq_n * r0)
{
	r0->dw0018 = 0x01;
}

// 0000A208: void I2CMasterSlaveAddrSet(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2)
void I2CMasterSlaveAddrSet(struct Eq_n * r0, ui32 r1, ui32 r2)
{
	r0->dw0000 = r2 | r1 << 0x01;
}

// 0000A210: void I2CMasterBusy()
void I2CMasterBusy()
{
}

// 0000A218: void I2CMasterBusBusy()
void I2CMasterBusBusy()
{
}

// 0000A220: void I2CMasterControl(Register (ptr32 Eq_n) r0, Register word32 r1)
void I2CMasterControl(struct Eq_n * r0, word32 r1)
{
	r0->dw0004 = r1;
}

// 0000A224: void I2CMasterErr(Register (ptr32 Eq_n) r0)
void I2CMasterErr(struct Eq_n * r0)
{
	ui32 r3_n = r0->dw0004;
	if (r3_n << 0x001F < 0x00 || (r3_n & 0x02) == 0x00)
		;
}

// 0000A23C: void I2CMasterDataPut(Register (ptr32 Eq_n) r0, Register ui32 r1)
void I2CMasterDataPut(struct Eq_n * r0, ui32 r1)
{
	r0->dw0008 = r1;
}

// 0000A240: void I2CMasterDataGet()
void I2CMasterDataGet()
{
}

// 0000A244: void I2CSlaveStatus()
void I2CSlaveStatus()
{
}

// 0000A248: void I2CSlaveDataPut(Register (ptr32 Eq_n) r0, Register word32 r1)
void I2CSlaveDataPut(struct Eq_n * r0, word32 r1)
{
	r0->dw0008 = r1;
}

// 0000A24C: void I2CSlaveDataGet()
void I2CSlaveDataGet()
{
}

// 0000A5C4: FlagGroup bool memcpy(Register Eq_n r0, Register Eq_n r1, Register Eq_n r2, Register Eq_n r4, Register Eq_n r5, Register Eq_n r6, Register Eq_n r7, Register Eq_n lr, Register out ptr32 r4Out, Register out ptr32 r5Out, Register out ptr32 r6Out, Register out ptr32 r7Out, Register out ptr32 lrOut)
bool memcpy(Eq_n r0, Eq_n r1, Eq_n r2, Eq_n r4, Eq_n r5, Eq_n r6, Eq_n r7, Eq_n lr, ptr32 & r4Out, ptr32 & r5Out, ptr32 & r6Out, ptr32 & r7Out, ptr32 & lrOut)
{
	Eq_n r5_n = r0;
	if (r2 > 0x0F)
	{
		if ((r1 | r0) << 0x001E != 0x00)
		{
			r5_n = r0;
l0000A630:
			Eq_n r3_n = 0x00;
			do
			{
				Mem100[r5_n + r3_n:byte] = (byte) (word32) Mem97[r1 + r3_n:byte];
				r3_n = (word32) r3_n + 0x01;
			} while (r3_n != r2);
l0000A63C:
			ptr32 r4_n;
			ptr32 r5_n;
			ptr32 r6_n;
			ptr32 r7_n;
			ptr32 lr_n;
			byte NZCV_n;
			lr();
			r4Out = r4_n;
			r5Out = r5_n;
			r6Out = r6_n;
			r7Out = r7_n;
			lrOut = lr_n;
			return SLICE(NZCV_n, bool, 2);
		}
		Eq_n r4_n = r1;
		Eq_n r3_n = r0;
		Eq_n r5_n = (word32) r0 + ((r2 - 0x10 >> 0x04) + 0x01 << 0x04);
		do
		{
			*r3_n = *r4_n;
			*((word32) r3_n + 0x04) = *((word32) r4_n + 0x04);
			*((word32) r3_n + 0x08) = *((word32) r4_n + 0x08);
			*((word32) r3_n + 0x0C) = *((word32) r4_n + 0x0C);
			r3_n = (word32) r3_n + 0x0010;
			r4_n = (word32) r4_n + 0x0010;
		} while (r5_n != r3_n);
		ui32 r6_n = r2 - 0x10 & ~0x0F;
		r5_n = (word32) r0 + (r6_n + 0x10);
		r1 = (word32) r1 + (r6_n + 0x10);
		if ((r2 & 0x0F) > 0x03)
		{
			uint32 r6_n = (r2 & 0x0F) - 0x04;
			int32 r3_n;
			uint32 r4_n = (r6_n >> 0x02) + 0x01;
			do
			{
				*((word32) r5_n + r3_n) = *((word32) r1 + r3_n);
				r3_n += 0x04;
			} while (r3_n != r4_n << 0x02);
			union Eq_n * r6_n = r6_n & ~0x03;
			r2 &= 0x03;
			r1 += r6_n + 0x04;
			r5_n += r6_n + 0x04;
		}
		else
			r2 &= 0x0F;
	}
	if (r2 == 0x00)
		goto l0000A63C;
	goto l0000A630;
}

