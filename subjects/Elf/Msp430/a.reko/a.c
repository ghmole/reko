// a.c
// Generated by decompiling a.out
// using Reko decompiler version 0.9.0.0.

#include "a.h"

// 09B2: void __write_char()
void __write_char()
{
}

// 00004000: void fn00004000(Register (ptr20 Eq_n) pc, Register ui20 sr, Register Eq_n r8)
void fn00004000(struct Eq_n * pc, ui20 sr, Eq_n r8)
{
	*(ptr16 *) 288 = 0x5A80;
	byte * r15_n = (byte *) 0x5B78;
	Eq_n r14_n = 0x0200;
	Eq_n r13_n = 0x021C;
	if (r13_n != r14_n)
	{
		do
		{
			*r14_n = *r15_n;
			++r15_n;
			++r14_n;
		} while (r14_n >= r13_n);
	}
	Eq_n r15_n = 0x021C;
	Eq_n r13_n = 2484;
	if (r13_n != r15_n)
	{
		do
		{
			*r15_n = 0x00;
			++r15_n;
		} while (r15_n >= r13_n);
	}
	main(pc, sr, r8);
}

// 4048: void task_idle(Register ui20 sr, Register Eq_n r8)
void task_idle(ui20 sr, Eq_n r8)
{
	word20 r15_n;
	ui20 sr_n = xTaskGetTickCount(sr, out r15_n);
	Eq_n r10_n = r15_n + 1000;
	while (true)
	{
		Eq_n r15_n;
		sr_n = xTaskGetTickCount(sr_n, out r15_n);
		if (r10_n - r15_n >= 0x01)
			break;
		printf(r8);
		r10_n.u1 = (word20) r15_n + 1000;
	}
}

// 4096: void task_n(Register (ptr20 Eq_n) pc, Register ui20 sr)
void task_n(struct Eq_n * pc, ui20 sr)
{
	word20 r15_n;
	ui20 sr_n = xTaskGetTickCount(sr, out r15_n);
	while (true)
	{
		*(union Eq_n *) 0x31 = *(union Eq_n *) 0x31 ^ 0x01;
		word20 r11_n;
		sr_n = vTaskDelayUntil(pc, putchar(pc, sr_n, 88, out r11_n), 500, fp - 0x02);
	}
}

// 40BC: void task_n(Register (ptr20 Eq_n) pc, Register ui20 sr)
void task_n(struct Eq_n * pc, ui20 sr)
{
	word20 r15_n;
	ui20 sr_n = xTaskGetTickCount(sr, out r15_n);
	while (true)
	{
		*(union Eq_n *) 0x31 = *(union Eq_n *) 0x31 ^ 0x02;
		word20 r11_n;
		sr_n = vTaskDelayUntil(pc, putchar(pc, sr_n, 0x59, out r11_n), 0xFA, fp - 0x02);
	}
}

// 40E2: void task_n(Register (ptr20 Eq_n) pc, Register ui20 sr)
void task_n(struct Eq_n * pc, ui20 sr)
{
	word20 r15_n;
	ui20 sr_n = xTaskGetTickCount(sr, out r15_n);
	while (true)
	{
		*(union Eq_n *) 0x31 = *(union Eq_n *) 0x31 ^ 0x04;
		word20 r11_n;
		sr_n = vTaskDelayUntil(pc, putchar(pc, sr_n, 0x5A, out r11_n), 0x19, fp - 0x02);
	}
}

// 414C: void main(Register (ptr20 Eq_n) pc, Register ui20 sr, Register Eq_n r8)
void main(struct Eq_n * pc, ui20 sr, Eq_n r8)
{
	__set_stackpointer(0x0A00);
	*(ptr16 *) 288 = 0x5A80;
	*(ptr16 *) 0x56 = ~0x1F;
	*(ptr16 *) 0x57 = 0x07;
	*(ptr16 *) 0x32 = 0x07;
	((union Eq_n *) 0x31)->u0 = 0x07;
	ui20 sr_n = init_uart_isr(pc, sr, 9600, 0x00, 0x10);
	uart_putchar_isr_mode(0x00);
	printf(r8);
	uart_putchar_isr_mode(0x01);
	word20 r15_n;
	word20 r15_n;
	word20 r15_n;
	word20 r15_n;
	vTaskStartScheduler(pc, xTaskCreate(pc, xTaskCreate(pc, xTaskCreate(pc, xTaskCreate(pc, sr_n, 0x00, 0x32, 0x414B, 0x4096, out r15_n), 0x00, 0x32, 0x414B, 0x40BC, out r15_n), 0x00, 0x32, 0x414B, 16610, out r15_n), 0x00, 0x96, 0x414B, 0x4048, out r15_n));
	while (true)
		;
}

// 420E: Register Eq_n msp430_compute_modulator_bits(Register Eq_n r12, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15)
Eq_n msp430_compute_modulator_bits(Eq_n r12, Eq_n r13, Eq_n r14, Eq_n r15)
{
	union Eq_n * v16_n = fp->ptr0002;
	Eq_n r12_n = fn00005B04(r14, r15, r12, r13);
	word20 r15_n;
	Eq_n r8_n = fn00005ADC(r14, r15, r12_n, 0x00, out r15_n) - r12;
	Eq_n r9_n = r15_n - r13 - (r8_n < 0x00);
	if (v16_n != null)
		*v16_n = (union Eq_n *) r12_n;
	Eq_n r7_n = 0x00;
	Eq_n r10_n = 0x00;
	Eq_n r11_n = 0x00;
	Eq_n r6_n = 0x00;
	do
	{
		r10_n += r8_n;
		Eq_n r14_n = (r14 ^ ~0x00) + 0x01;
		r11_n = r11_n + r9_n + (r10_n <u 0x00);
		if (r11_n * 0x02 + (r10_n * 0x02 <u 0x00) - ((r15 ^ ~0x00) + (r14_n <u 0x00)) - (r10_n * 0x02 - r14_n <u 0x00) < 0x00)
		{
			r10_n += r14;
			r11_n = r11_n + r15 + (r10_n <u 0x00);
			Eq_n r15_n = 0x01;
			Eq_n r14_n = r6_n;
			if (r6_n != 0x00)
			{
				do
				{
					r15_n *= 0x02;
					--r14_n;
				} while (r14_n != 0x00);
			}
			r7_n |= r15_n;
		}
		r6_n = (word24) r6_n + 0x01;
	} while (r6_n >= 0x08);
	return r7_n;
}

// 42CC: Register ui20 init_uart_isr(Register (ptr20 Eq_n) pc, Register ui20 sr, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15)
ui20 init_uart_isr(struct Eq_n * pc, ui20 sr, Eq_n r13, Eq_n r14, Eq_n r15)
{
	Eq_n bLoc10 = (byte) wLoc10;
	Eq_n v15_n = fp->t0002;
	Eq_n v16_n = fp->t0004;
	Eq_n v17_n = fp->t0006;
	++globals->ptr0218;
	Eq_n r15_n;
	ui20 sr_n = xQueueCreate(pc, sr & ~0x08, v17_n, out r15_n);
	globals->a021C = r15_n;
	Eq_n r15_n;
	ui20 sr_n = xQueueCreate(pc, sr_n, v17_n, out r15_n);
	globals->t021E = r15_n;
	((union Eq_n *) 0x78)->u1 = 0x01;
	*(union Eq_n *) 0x78 |= 0x10;
	*(union Eq_n *) 121 = r15 & 0x30;
	Eq_n r15_n = msp430_compute_modulator_bits(v15_n, v16_n, r13, r14);
	*(union Eq_n *) 0x7C = bLoc10;
	*(union Eq_n *) 0x7D = __swpb(wLoc10) & ~0x00;
	*(union Eq_n *) 0x7B = r15_n;
	*(union Eq_n *) 0x05 |= 0x30;
	((union Eq_n *) 0x78)->u0 = 0x10;
	*(union Eq_n *) 0x1B |= ~0x3F;
	*(union Eq_n *) 0x01 |= 0x30;
	if (0x0218 != 0x00)
	{
		globals->ptr0218 += ~0x00;
		if (globals->ptr0218 == 0x00)
			sr_n |= 0x08;
	}
	return sr_n;
}

// 4380: void getchar(Register (ptr20 Eq_n) pc, Register ui20 sr)
void getchar(struct Eq_n * pc, ui20 sr)
{
	x_getchar(pc, sr, 100, fp - 0x02) == 0x00;
}

// 439C: void uart_putchar_isr_mode(Register Eq_n r15)
void uart_putchar_isr_mode(Eq_n r15)
{
	globals->a0200 = r15;
}

// 43A2: Register ui20 putchar(Register (ptr20 Eq_n) pc, Register ui20 sr, Register Eq_n r15, Register out Eq_n r11Out)
ui20 putchar(struct Eq_n * pc, ui20 sr, Eq_n r15, union Eq_n & r11Out)
{
	Eq_n r11_n = r15;
	if (r15 == 0x0A)
		putchar(pc, sr, 0x0D, out r11_n);
	Eq_n r15_n;
	if (0x0200 == 0x00)
	{
		do
			;
		while ((121 & 0x01) == 0x00);
		*(union Eq_n *) 0x7F = r11_n;
		r15_n.u1 = 0x01;
	}
	else
		sr = x_putchar(pc, sr, 100, r11_n, out r15_n);
	r11Out.u0 = <invalid>;
	return sr;
}

// 43E4: Register Eq_n x_getchar(Register (ptr20 Eq_n) pc, Register ui20 sr, Register Eq_n r14, Register Eq_n r15)
Eq_n x_getchar(struct Eq_n * pc, ui20 sr, Eq_n r14, Eq_n r15)
{
	word20 r15_n;
	xQueueReceive(pc, sr, r14, r15, 0x021C, out r15_n);
	if (r15_n == 0x00)
		return 0x00;
	return 0x01;
}

// 43FC: Register ui20 x_putchar(Register (ptr20 Eq_n) pc, Register ui20 sr, Register Eq_n r14, Register Eq_n r15, Register out Eq_n r15Out)
ui20 x_putchar(struct Eq_n * pc, ui20 sr, Eq_n r14, Eq_n r15, union Eq_n & r15Out)
{
	++globals->ptr0218;
	ui20 sr_n = sr & ~0x08;
	if (0x0221 != 0x00)
	{
		Eq_n r15_n;
		sr_n = xQueueSend(pc, sr_n, r14, fp - 0x02, 0x021E, out r15_n);
		if (0x0221 != 0x00 || r15_n != 0x01)
		{
l00004420:
			if (0x0218 != 0x00)
			{
				globals->ptr0218 += ~0x00;
				if (globals->ptr0218 == 0x00)
					sr_n |= 0x08;
			}
			r15Out.u0 = 0x01;
			return sr_n;
		}
		word20 r15_n;
		sr_n = xQueueReceive(pc, sr_n, 0x00, fp - 0x02, 0x021E, out r15_n);
	}
	globals->ptr0220 = 0x00;
	*(union Eq_n *) 0x7F = r15;
	goto l00004420;
}

// 4450: void vRxISR(Register (ptr20 Eq_n) pc, Register ui20 sr)
void vRxISR(struct Eq_n * pc, ui20 sr)
{
	word20 r15_n;
	ui20 sr_n = xQueueSendFromISR(sr, 0x00, fp - 0x0A, 0x021C, out r15_n);
	if (r15_n != 0x00)
	{
		word20 r11_n;
		word20 r10_n;
		word20 r9_n;
		word20 r8_n;
		vPortYield(pc, sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
	}
}

// 4480: void vTxISR(Register ui20 sr)
void vTxISR(ui20 sr)
{
	if (xQueueReceiveFromISR(sr, fp - 0x0C, fp - 0x0A, 0x021E) != 0x01)
		globals->ptr0220 = 0x01;
	else
		*(union Eq_n *) 0x7F = bLoc0A;
}

// 44B4: Register ui20 xTaskCreate(Register (ptr20 Eq_n) pc, Register ui20 sr, Register Eq_n r12, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15, Register out Eq_n r15Out)
ui20 xTaskCreate(struct Eq_n * pc, ui20 sr, Eq_n r12, Eq_n r13, Eq_n r14, Eq_n r15, union Eq_n & r15Out)
{
	Eq_n r10_n;
	Eq_n v15_n = fp->t0002;
	union Eq_n * v16_n = fp->ptr0004;
	Eq_n r15_n;
	ui20 sr_n = prvAllocateTCBAndStack(pc, sr, r13, out r15_n);
	if (r15_n != 0x00)
	{
		prvInitialiseTCBVariables(v15_n, r14, r13, r15_n);
		*r15_n = pxPortInitialiseStack(r12, r15, (word24) *((word24) r15_n + 0x02) + *((word24) r15_n + 0x0024) * 0x02 - 0x02);
		++globals->ptr0218;
		++globals->ptr0206;
		sr_n &= ~0x08;
		if (0x0207 != 0x00)
		{
			if (0x020E == 0x00 && v15_n < globals->t0208)
				globals->t0202 = r15_n;
		}
		else
		{
			globals->t0202 = r15_n;
			prvInitialiseTaskLists();
		}
		Eq_n v25_n = *((word24) r15_n + 0x06);
		if (522 >= v25_n)
			globals->t020A = v25_n;
		((word24) r15_n + 0x04)->u0 = 0x0214;
		++globals->ptr0214;
		*((word24) r15_n + 0x08) = 0x00;
		if (0x020C >= v25_n)
			globals->t020C = v25_n;
		vListInsertEnd((word24) r15_n + 0x08, v25_n * 0x10 + 0x0222);
		r10_n.u0 = 0x01;
		if (0x0218 != 0x00)
		{
			globals->ptr0218 += ~0x00;
			if (globals->ptr0218 == 0x00)
				sr_n |= 0x08;
		}
	}
	else
		r10_n.u0 = ~0x00;
	if (r10_n == 0x01)
	{
		if (v16_n != null)
			*v16_n = (union Eq_n *) r15_n;
		if (0x020E != 0x00 && globals->t0208 >= v15_n)
		{
			word20 r9_n;
			word20 r11_n;
			word20 r8_n;
			sr_n = vPortYield(pc, sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
	}
	r15Out = r10_n;
	return sr_n;
}

// 45B6: void vTaskDelete(Register (ptr20 Eq_n) pc, Register ui20 sr, Register Eq_n r15)
void vTaskDelete(struct Eq_n * pc, ui20 sr, Eq_n r15)
{
	++globals->ptr0218;
	ui20 sr_n = sr & ~0x08;
	Eq_n r11_n = r15;
	if (r15 == 0x00)
		r11_n.u0 = 0x0202;
	Eq_n r10_n = (word16) r11_n.u0 + 0x08;
	vListRemove(r10_n);
	if (*((word16) r11_n.u0 + 0x001A) != 0x00)
		vListRemove((word16) r11_n.u0 + 0x0012);
	vListInsertEnd(r10_n, 662);
	++globals->ptr0204;
	if (0x0218 != 0x00)
	{
		globals->ptr0218 += ~0x00;
		if (globals->ptr0218 == 0x00)
			sr_n |= 0x08;
	}
	if (r15 == 0x00)
	{
		word20 r9_n;
		word20 r10_n;
		word20 r11_n;
		word20 r8_n;
		vPortYield(pc, sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
	}
}

// 461A: Register ui20 vTaskDelayUntil(Register (ptr20 Eq_n) pc, Register ui20 sr, Register Eq_n r14, Register Eq_n r15)
ui20 vTaskDelayUntil(struct Eq_n * pc, ui20 sr, Eq_n r14, Eq_n r15)
{
	ui20 sr_n = vTaskSuspendAll(sr);
	Eq_n v8_n = *r15;
	Eq_n r10_n = 0x00;
	word20 r11_n = r14 + v8_n;
	if (0x0208 >= v8_n)
	{
		if (r11_n < v8_n)
			goto l00004640;
	}
	else if (r11_n >= v8_n)
		goto l0000463E;
	if (0x0208 < r11_n)
		goto l00004640;
l0000463E:
	r10_n.u1 = 0x01;
l00004640:
	*r15 = r11_n;
	if (r10_n != 0x00)
	{
		struct Eq_n * r14_n;
		Eq_n r15_n;
		vListRemove(522);
		globals->t020A = r11_n;
		if (r11_n >= 0x0208)
		{
			r14_n = &globals->t020A;
			r15_n.u0 = 644;
		}
		else
		{
			r14_n = &globals->t020A;
			r15_n.u0 = 0x0282;
		}
		vListInsert(r14_n, r15_n);
	}
	word20 r15_n;
	ui20 sr_n = xTaskResumeAll(pc, sr_n, out r15_n);
	if (r15_n == 0x00)
	{
		word20 r10_n;
		word20 r8_n;
		word20 r11_n;
		word20 r9_n;
		sr_n = vPortYield(pc, sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
	}
	return sr_n;
}

// 469E: void vTaskDelay(Register (ptr20 Eq_n) pc, Register ui20 sr, Register word20 r15)
void vTaskDelay(struct Eq_n * pc, ui20 sr, word20 r15)
{
	Eq_n r15_n = 0x00;
	if (r15 != 0x00)
	{
		struct Eq_n * r14_n;
		Eq_n r15_n;
		ui20 sr_n = vTaskSuspendAll(sr);
		vListRemove(522);
		Eq_n r11_n = r15 + 0x0208;
		globals->t020A = r11_n;
		if (r11_n >= 0x0208)
		{
			r14_n = &globals->t020A;
			r15_n.u0 = 644;
		}
		else
		{
			r14_n = &globals->t020A;
			r15_n.u0 = 0x0282;
		}
		vListInsert(r14_n, r15_n);
		sr = xTaskResumeAll(pc, sr_n, out r15_n);
	}
	if (r15_n == 0x00)
	{
		word20 r10_n;
		word20 r11_n;
		word20 r8_n;
		word20 r9_n;
		vPortYield(pc, sr, out r8_n, out r9_n, out r10_n, out r11_n);
	}
}

// 4702: void vTaskStartScheduler(Register (ptr20 Eq_n) pc, Register ui20 sr)
void vTaskStartScheduler(struct Eq_n * pc, ui20 sr)
{
	if (0x0202 != 0x00)
	{
		Eq_n r15_n;
		xTaskCreate(pc, sr, 0x00, 0x32, 18172, 18860, out r15_n);
		if (r15_n == 0x01)
		{
			globals->ptr020E = 0x01;
			globals->t0208.u0 = 0x00;
			xPortStartScheduler(pc);
		}
	}
}

// 4736: void vTaskEndScheduler()
void vTaskEndScheduler()
{
	globals->ptr020E = 0x00;
	vPortEndScheduler();
}

// 4742: Register ui20 vTaskSuspendAll(Register ui20 sr)
ui20 vTaskSuspendAll(ui20 sr)
{
	++globals->ptr0218;
	++globals->ptr0210;
	ui20 sr_n = sr & ~0x08;
	if (0x0218 != 0x00)
	{
		globals->ptr0218 += ~0x00;
		if (globals->ptr0218 == 0x00)
			sr_n |= 0x08;
	}
	return sr_n;
}

// 475C: Register ui20 xTaskResumeAll(Register (ptr20 Eq_n) pc, Register ui20 sr, Register out Eq_n r15Out)
ui20 xTaskResumeAll(struct Eq_n * pc, ui20 sr, union Eq_n & r15Out)
{
	++globals->ptr0218;
	globals->ptr0210 += ~0x00;
	Eq_n r8_n = 0x00;
	ui20 sr_n = sr & ~0x08;
	if (globals->ptr0210 == 0x00 && 0x0206 != 0x00)
	{
		Eq_n r9_n = 0x00;
		while (true)
		{
			Eq_n r11_n;
			if (646 != 0x00)
				r11_n = globals->ptr028A->t0006;
			else
				r11_n.u0 = 0x00;
			if (r11_n == 0x00)
				break;
			vListRemove((word16) r11_n.u0 + 0x0012);
			Eq_n r10_n = (word16) r11_n.u0 + 0x08;
			vListRemove(r10_n);
			*((word16) r11_n.u0 + 0x08) = 0x00;
			Eq_n v14_n = *((word16) r11_n.u0 + 0x06);
			if (0x020C >= v14_n)
				globals->t020C = v14_n;
			vListInsertEnd(r10_n, v14_n * 0x10 + 0x0222);
			if (globals->t0208 >= *((word16) r11_n.u0 + 0x06))
				r9_n.u1 = 0x01;
		}
		if (0x0212 != 0x00)
		{
			if (0x0212 != 0x00)
			{
				do
				{
					vTaskIncrementTick();
					globals->ptr0212 += ~0x00;
				} while (globals->ptr0212 != 0x00);
			}
			r9_n.u1 = 0x01;
		}
		if (r9_n == 0x01)
		{
			word20 r10_n;
			word20 r9_n;
			word20 r11_n;
			sr_n = vPortYield(pc, sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
	}
	if (0x0218 != 0x00)
	{
		globals->ptr0218 += ~0x00;
		if (globals->ptr0218 == 0x00)
			sr_n |= 0x08;
	}
	r15Out = r8_n;
	return sr_n;
}

// 481E: Register ui20 xTaskGetTickCount(Register ui20 sr, Register out Eq_n r15Out)
ui20 xTaskGetTickCount(ui20 sr, union Eq_n & r15Out)
{
	++globals->ptr0218;
	ui20 sr_n = sr & ~0x08;
	Eq_n r15_n = 0x0208;
	if (globals->ptr0218 != 0x00)
	{
		globals->ptr0218 += ~0x00;
		if (globals->ptr0218 == 0x00)
			sr_n |= 0x08;
	}
	r15Out = r15_n;
	return sr_n;
}

// 4834: void uxTaskGetNumberOfTasks()
void uxTaskGetNumberOfTasks()
{
	++globals->ptr0218;
	if (globals->ptr0218 != 0x00)
	{
		globals->ptr0218 += ~0x00;
		globals->ptr0218 != 0x00;
	}
}

// 484A: void vTaskIncrementTick()
void vTaskIncrementTick()
{
	if (0x0210 == 0x00)
	{
		globals->t0208 = (word24) globals->t0208 + 0x01;
		if (globals->t0208 == 0x00)
		{
			globals->ptr0282 = 644;
			globals->ptr0284 = 0x0282;
		}
		while (true)
		{
			Eq_n r11_n;
			Eq_n r15_n = 0x0282;
			if (*r15_n != 0x00)
				r11_n = *((word24) *((word24) *((word24) r15_n + 0x02) + 0x02) + 0x06);
			else
				r11_n.u0 = 0x00;
			if (r11_n == 0x00 || 0x0208 >= *((word24) r11_n + 0x08))
				break;
			Eq_n r10_n = (word24) r11_n + 0x08;
			vListRemove(r10_n);
			if (*((word24) r11_n + 0x001A) != 0x00)
				vListRemove((word24) r11_n + 0x0012);
			*((word24) r11_n + 0x08) = 0x00;
			Eq_n v18_n = *((word24) r11_n + 0x06);
			if (0x020C >= v18_n)
				globals->t020C = v18_n;
			vListInsertEnd(r10_n, v18_n * 0x10 + 0x0222);
		}
	}
	else
		++globals->ptr0212;
}

// 48DA: void vTaskPlaceOnEventList(Register Eq_n r14, Register Eq_n r15)
void vTaskPlaceOnEventList(Eq_n r14, Eq_n r15)
{
	struct Eq_n * r14_n;
	Eq_n r15_n;
	vListInsert(&globals->ptr0214, r15);
	vListRemove(522);
	Eq_n r11_n = (word20) r14.u0 + 0x0208;
	globals->t020A = r11_n;
	if (r11_n >= 0x0208)
	{
		r14_n = &globals->t020A;
		r15_n.u0 = 644;
	}
	else
	{
		r14_n = &globals->t020A;
		r15_n.u0 = 0x0282;
	}
	vListInsert(r14_n, r15_n);
}

// 4930: Register Eq_n xTaskRemoveFromEventList(Register Eq_n r15)
Eq_n xTaskRemoveFromEventList(Eq_n r15)
{
	Eq_n r10_n;
	if (*r15 != 0x00)
		r10_n = *((word24) *((word24) *((word24) r15 + 0x02) + 0x02) + 0x06);
	else
		r10_n.u0 = 0x00;
	Eq_n r14_n;
	Eq_n r15_n;
	vListRemove((word24) r10_n + 0x0012);
	if (0x0210 == 0x00)
	{
		vListRemove((word24) r10_n + 0x08);
		*((word24) r10_n + 0x08) = 0x00;
		Eq_n v13_n = *((word24) r10_n + 0x06);
		if (0x020C >= v13_n)
			globals->t020C = v13_n;
		r15_n = v13_n * 0x10 + 0x0222;
		r14_n = (word24) r10_n + 0x08;
	}
	else
	{
		r14_n = (word24) r10_n + 0x0012;
		r15_n.u0 = 646;
	}
	Eq_n r15_n;
	vListInsertEnd(r14_n, r15_n);
	if (globals->t0208 >= *((word24) r10_n + 0x06))
		r15_n.u0 = 0x01;
	else
		r15_n.u0 = 0x00;
	return r15_n;
}

// 49AC: void prvIdleTask(Register (ptr20 Eq_n) pc, Register ui20 sr)
void prvIdleTask(struct Eq_n * pc, ui20 sr)
{
	while (true)
	{
		sr = prvCheckTasksWaitingTermination(pc, sr);
		if (0x0224 < 0x00)
		{
			word20 r8_n;
			word20 r9_n;
			word20 r10_n;
			word20 r11_n;
			sr = vPortYield(pc, sr, out r8_n, out r9_n, out r10_n, out r11_n);
		}
	}
}

// 49BE: void prvInitialiseTCBVariables(Register Eq_n r12, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15)
void prvInitialiseTCBVariables(Eq_n r12, Eq_n r13, Eq_n r14, Eq_n r15)
{
	*((word24) r15 + 0x0024) = r14;
	strncpy(0x08, r13, (word24) r15 + 0x001C);
	*((word24) r15 + 0x0023) = 0x00;
	Eq_n r10_n = r12;
	if (r12 < 0x04)
		r10_n.u0 = 0x03;
	*((word24) r15 + 0x06) = r10_n;
	vListInitialiseItem((word24) r15 + 0x08);
	vListInitialiseItem((word24) r15 + 0x0012);
	*((word24) r15 + 0x0E) = r15;
	*((word24) r15 + 0x0012) = 0x04 - r10_n;
	*((word24) r15 + 0x0018) = r15;
}

// 4A12: void prvInitialiseTaskLists()
void prvInitialiseTaskLists()
{
	Eq_n r11_n = 0x00;
	do
	{
		vListInitialise(r11_n * 0x10 + 0x0222);
		r11_n = (word24) r11_n + 0x01;
	} while (r11_n >= 0x04);
	vListInitialise(0x0262);
	vListInitialise(0x0272);
	vListInitialise(646);
	vListInitialise(662);
	globals->ptr0282 = 0x0262;
	globals->ptr0284 = 0x0272;
}

// 4A5E: Register ui20 prvCheckTasksWaitingTermination(Register (ptr20 Eq_n) pc, Register ui20 sr)
ui20 prvCheckTasksWaitingTermination(struct Eq_n * pc, ui20 sr)
{
	if (0x0204 != 0x00)
	{
		ui20 sr_n = vTaskSuspendAll(sr);
		Eq_n r11_n = 0x00;
		if (662 == 0x00)
			r11_n.u1 = 0x01;
		word20 r15_n;
		sr = xTaskResumeAll(pc, sr_n, out r15_n);
		if (r11_n == 0x00)
		{
			Eq_n r11_n;
			++globals->ptr0218;
			sr &= ~0x08;
			if (662 != 0x00)
				r11_n = globals->ptr029A->t0006;
			else
				r11_n.u1 = 0x00;
			vListRemove((word16) r11_n.u1 + 0x08);
			globals->ptr0206 += ~0x00;
			globals->ptr0204 += ~0x00;
			if (0x0218 != 0x00)
			{
				globals->ptr0218 += ~0x00;
				if (globals->ptr0218 == 0x00)
					sr |= 0x08;
			}
			prvDeleteTCB();
		}
	}
	return sr;
}

// 4AC2: Register ui20 prvAllocateTCBAndStack(Register (ptr20 Eq_n) pc, Register ui20 sr, Register Eq_n r15, Register out Eq_n r15Out)
ui20 prvAllocateTCBAndStack(struct Eq_n * pc, ui20 sr, Eq_n r15, union Eq_n & r15Out)
{
	Eq_n r15_n;
	ui20 sr_n = pvPortMalloc(pc, sr, 0x26, out r15_n);
	Eq_n r11_n = r15_n;
	if (r15_n != 0x00)
	{
		Eq_n r15_n;
		sr_n = pvPortMalloc(pc, sr_n, r15 * 0x02, out r15_n);
		*((word24) r15_n + 0x02) = r15_n;
		if (r15_n == 0x00)
		{
			vPortFree();
			r11_n.u0 = 0x00;
		}
		else
			sr_n = memset(sr_n, r15 * 0x02, 0xA5, r15_n);
	}
	r15Out = r11_n;
	return sr_n;
}

// 4B02: void prvDeleteTCB()
void prvDeleteTCB()
{
	vPortFree();
	vPortFree();
}

// 4B18: void vTaskSwitchContext()
void vTaskSwitchContext()
{
	if (0x0210 == 0x00)
	{
		while (globals->a0222[0x020C] == 0x00)
			globals->t020C = (word24) globals->t020C + 0x0000FFFF;
		Eq_n r13_n = 0x0222;
		(word24) r13_n + 0x020C * 0x10 + 0x04 = (ui20) ((word24) r13_n + 0x020C * 0x10 + 0x04 + 0x02);
		if ((word24) r13_n + 0x020C * 0x10 + 0x04 == ((word24) r13_n + 0x020C * 0x10) + 0x02)
			globals->a0226[0x020C] = *((word128) globals->a0226[0x020C] + 0x02);
		globals->t0202 = globals->a0226[0x020C].ptr0004->w0002;
	}
}

// 4BD4: void vListInitialise(Register Eq_n r15)
void vListInitialise(Eq_n r15)
{
	*((word24) r15 + 0x02) = (word24) r15 + 0x06;
	*((word24) r15 + 0x04) = (word24) r15 + 0x06;
	((word24) r15 + 0x06)->u0 = ~0x00;
	*((word24) r15 + 0x08) = (word24) r15 + 0x06;
	*((word24) r15 + 0x0A) = (word24) r15 + 0x06;
	((word24) r15 + 0x0C)->u0 = 0x00;
	vListInitialiseItem((word24) r15 + 0x06);
	r15->u0 = 0x00;
}

// 4C00: void vListInitialiseItem(Register (ptr20 Eq_n) r15)
void vListInitialiseItem(struct Eq_n * r15)
{
	r15->w0008 = 0x00;
}

// 4C06: void vListInsertEnd(Register Eq_n r14, Register Eq_n r15)
void vListInsertEnd(Eq_n r14, Eq_n r15)
{
	Eq_n v5_n = *((word24) r15 + 0x04);
	*((word24) r14 + 0x02) = *((word24) v5_n + 0x02);
	*((word24) r14 + 0x04) = *((word24) r15 + 0x04);
	*((word24) *((word24) v5_n + 0x02) + 0x04) = r14;
	*((word24) v5_n + 0x02) = r14;
	*((word24) r15 + 0x04) = r14;
	*((word24) r14 + 0x08) = r15;
	*r15 = (word24) *r15 + 0x01;
}

// 4C32: void vListInsert(Register (ptr24 Eq_n) r14, Register Eq_n r15)
void vListInsert(struct Eq_n * r14, Eq_n r15)
{
	struct Eq_n * r13_n;
	cup16 v6_n = r14->w0000;
	if (v6_n != ~0x00)
	{
		struct Eq_n * v10_n = *((word24) r15 + 0x02);
		r13_n = v10_n;
		if (v6_n < *v10_n->t0002)
		{
			do
			{
				struct Eq_n * v15_n = r13_n->t0002;
				r13_n = v15_n;
			} while (v6_n < *v15_n->t0002);
		}
	}
	else
	{
		struct Eq_n * v18_n = *((word24) r15 + 0x02);
		r13_n = v18_n;
		if (*v18_n->t0002 >= ~0x00)
		{
			do
			{
				struct Eq_n * v21_n = r13_n->t0002;
				r13_n = v21_n;
			} while (*v21_n->t0002 >= v6_n);
		}
	}
	r14->t0002 = r13_n->t0002;
	*((word24) r14->t0002 + 0x04) = r14;
	r14->ptr0004 = r13_n;
	r13_n->t0002 = r14;
	r14->t0008 = r15;
	*r15 = (word24) *r15 + 0x01;
}

// 4C98: void vListRemove(Register Eq_n r15)
void vListRemove(Eq_n r15)
{
	Eq_n v5_n = *((word24) r15 + 0x02);
	*((word24) v5_n + 0x04) = *((word24) r15 + 0x04);
	Eq_n v8_n = *((word24) r15 + 0x04);
	*((word24) v8_n + 0x02) = v5_n;
	Eq_n v11_n = *((word24) r15 + 0x08);
	if (*((word24) v11_n + 0x04) == r15)
		*((word24) v11_n + 0x04) = v8_n;
	((word24) r15 + 0x08)->u0 = 0x00;
	*v11_n = (word24) *v11_n + 0x0000FFFF;
}

// 4CC4: Register ui20 xQueueCreate(Register (ptr20 Eq_n) pc, Register ui20 sr, Register Eq_n r15, Register out Eq_n r15Out)
ui20 xQueueCreate(struct Eq_n * pc, ui20 sr, Eq_n r15, union Eq_n & r15Out)
{
	if (r15 != 0x00)
	{
		word20 r15_n;
		sr = pvPortMalloc(pc, sr, 0x32, out r15_n);
		if (r15_n != 0x00)
			;
	}
	Eq_n r15_n = 0x00;
	r15Out = r15_n;
	return sr;
}

// 4D7E: Register ui20 xQueueSend(Register (ptr20 Eq_n) pc, Register ui20 sr, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15, Register out Eq_n r15Out)
ui20 xQueueSend(struct Eq_n * pc, ui20 sr, Eq_n r13, Eq_n r14, Eq_n r15, union Eq_n & r15Out)
{
	ui20 sr_n = vTaskSuspendAll(sr) & ~0x08;
	++globals->ptr0218;
	*((word24) r15 + 0x002E) = (word24) *((word24) r15 + 0x002E) + 0x01;
	*((word24) r15 + 0x0030) = (word24) *((word24) r15 + 0x0030) + 0x01;
	Eq_n r11_n = r15;
	Eq_n r9_n = r14;
	if (0x0218 != 0x00)
	{
		globals->ptr0218 += ~0x00;
		if (globals->ptr0218 == 0x00)
			sr_n |= 0x08;
	}
	word20 r15_n;
	ui20 sr_n = prvIsQueueFull(sr_n, r15, out r15_n);
	if (r15_n != 0x00 && r13 != 0x00)
	{
		vTaskPlaceOnEventList(r13, (word24) r15 + 0x08);
		++globals->ptr0218;
		word20 r15_n;
		word20 r15_n;
		ui20 sr_n = xTaskResumeAll(pc, prvUnlockQueue(sr_n & ~0x08, r15, out r15_n), out r15_n);
		if (r15_n == 0x00)
		{
			word20 r8_n;
			word20 r10_n;
			sr_n = vPortYield(pc, sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
		sr_n = vTaskSuspendAll(sr_n) & ~0x08;
		++globals->ptr0218;
		*((word24) r11_n + 0x002E) = (word24) *((word24) r11_n + 0x002E) + 0x01;
		*((word24) r11_n + 0x0030) = (word24) *((word24) r11_n + 0x0030) + 0x01;
		if (0x0218 != 0x00)
		{
			globals->ptr0218 += ~0x00;
			if (globals->ptr0218 == 0x00)
				sr_n |= 0x08;
		}
		if (0x0218 != 0x00)
		{
			globals->ptr0218 += ~0x00;
			if (globals->ptr0218 == 0x00)
				sr_n |= 0x08;
		}
	}
	Eq_n r10_n;
	++globals->ptr0218;
	ui20 sr_n = sr_n & ~0x08;
	if (*((word24) r11_n + 0x0028) < *((word24) r11_n + 0x002A))
		r10_n.u0 = ~0x02;
	else
	{
		sr_n = memcpy(sr_n, *((word24) r11_n + 44), r9_n, *((word24) r11_n + 0x04));
		*((word24) r11_n + 0x0028) = (word24) *((word24) r11_n + 0x0028) + 0x01;
		word20 r15_n = Mem166[r11_n + 0x04:word16] + Mem166[r11_n + 44:word16];
		*((word24) r11_n + 0x04) = r15_n;
		if (r15_n < *((word24) r11_n + 0x02))
			*((word24) r11_n + 0x04) = *r11_n;
		*((word24) r11_n + 0x0030) = (word24) *((word24) r11_n + 0x0030) + 0x01;
		r10_n.u0 = 0x01;
	}
	if (0x0218 != 0x00)
	{
		globals->ptr0218 += ~0x00;
		if (globals->ptr0218 == 0x00)
			sr_n |= 0x08;
	}
	ui20 sr_n;
	word20 r15_n;
	ui20 sr_n = prvUnlockQueue(sr_n, r11_n, out r15_n);
	if (r15_n != 0x00)
	{
		word20 r15_n;
		sr_n = xTaskResumeAll(pc, sr_n, out r15_n);
		if (r15_n == 0x00)
		{
			word20 r11_n;
			word20 r8_n;
			word20 r9_n;
			sr_n = vPortYield(pc, sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
	}
	else
	{
		word20 r15_n;
		sr_n = xTaskResumeAll(pc, sr_n, out r15_n);
	}
	r15Out = r10_n;
	return sr_n;
}

// 4E84: Register ui20 xQueueSendFromISR(Register ui20 sr, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15, Register out Eq_n r15Out)
ui20 xQueueSendFromISR(ui20 sr, Eq_n r13, Eq_n r14, Eq_n r15, union Eq_n & r15Out)
{
	Eq_n r13_n;
	if (*((word24) r15 + 0x0028) >= *((word24) r15 + 0x002A))
	{
		sr = memcpy(sr, *((word24) r15 + 44), r14, *((word24) r15 + 0x04));
		*((word24) r15 + 0x0028) = (word24) *((word24) r15 + 0x0028) + 0x01;
		word20 r15_n = Mem33[r15 + 0x04:word16] + Mem33[r15 + 44:word16];
		*((word24) r15 + 0x04) = r15_n;
		if (r15_n < *((word24) r15 + 0x02))
			*((word24) r15 + 0x04) = *r15;
		word16 v22_n = *((word24) r15 + 0x0030);
		if (v22_n != ~0x00)
			*((word24) r15 + 0x0030) = v22_n + 0x01;
		else if (r13 == 0x00 && (*((word24) r15 + 0x0018) != 0x00 && xTaskRemoveFromEventList((word24) r15 + 0x0018) != 0x00))
		{
			r13_n.u0 = 0x01;
l4EE8:
			r15Out = r13_n;
			return sr;
		}
	}
	r13_n = r13;
	goto l4EE8;
}

// 4EF0: Register ui20 xQueueReceive(Register (ptr20 Eq_n) pc, Register ui20 sr, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15, Register out Eq_n r15Out)
ui20 xQueueReceive(struct Eq_n * pc, ui20 sr, Eq_n r13, Eq_n r14, Eq_n r15, union Eq_n & r15Out)
{
	ui20 sr_n = vTaskSuspendAll(sr) & ~0x08;
	++globals->ptr0218;
	*((word24) r15 + 0x002E) = (word24) *((word24) r15 + 0x002E) + 0x01;
	*((word24) r15 + 0x0030) = (word24) *((word24) r15 + 0x0030) + 0x01;
	Eq_n r11_n = r15;
	Eq_n r9_n = r14;
	if (0x0218 != 0x00)
	{
		globals->ptr0218 += ~0x00;
		if (globals->ptr0218 == 0x00)
			sr_n |= 0x08;
	}
	word20 r15_n;
	ui20 sr_n = prvIsQueueEmpty(sr_n, r15, out r15_n);
	if (r15_n != 0x00 && r13 != 0x00)
	{
		vTaskPlaceOnEventList(r13, (word24) r15 + 0x0018);
		++globals->ptr0218;
		word20 r15_n;
		word20 r15_n;
		ui20 sr_n = xTaskResumeAll(pc, prvUnlockQueue(sr_n & ~0x08, r15, out r15_n), out r15_n);
		if (r15_n == 0x00)
		{
			word20 r8_n;
			word20 r10_n;
			sr_n = vPortYield(pc, sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
		sr_n = vTaskSuspendAll(sr_n) & ~0x08;
		++globals->ptr0218;
		*((word24) r11_n + 0x002E) = (word24) *((word24) r11_n + 0x002E) + 0x01;
		*((word24) r11_n + 0x0030) = (word24) *((word24) r11_n + 0x0030) + 0x01;
		if (0x0218 != 0x00)
		{
			globals->ptr0218 += ~0x00;
			if (globals->ptr0218 == 0x00)
				sr_n |= 0x08;
		}
		if (0x0218 != 0x00)
		{
			globals->ptr0218 += ~0x00;
			if (globals->ptr0218 == 0x00)
				sr_n |= 0x08;
		}
	}
	Eq_n r10_n;
	++globals->ptr0218;
	ui20 sr_n = sr_n & ~0x08;
	cup16 v14_n = *((word24) r11_n + 0x0028);
	if (v14_n != 0x00)
	{
		Eq_n v15_n = *((word24) r11_n + 44);
		word20 r15_n = Mem139[r11_n + 0x06:word16] + v15_n;
		*((word24) r11_n + 0x06) = r15_n;
		if (r15_n < *((word24) r11_n + 0x02))
			*((word24) r11_n + 0x06) = *r11_n;
		*((word24) r11_n + 0x0028) = v14_n + ~0x00;
		sr_n = memcpy(sr_n, v15_n, *((word24) r11_n + 0x06), r9_n);
		*((word24) r11_n + 0x002E) = (word24) *((word24) r11_n + 0x002E) + 0x01;
		r10_n.u0 = 0x01;
	}
	else
		r10_n.u0 = 0x00;
	if (0x0218 != 0x00)
	{
		globals->ptr0218 += ~0x00;
		if (globals->ptr0218 == 0x00)
			sr_n |= 0x08;
	}
	ui20 sr_n;
	word20 r15_n;
	ui20 sr_n = prvUnlockQueue(sr_n, r11_n, out r15_n);
	if (r15_n != 0x00)
	{
		word20 r15_n;
		sr_n = xTaskResumeAll(pc, sr_n, out r15_n);
		if (r15_n == 0x00)
		{
			word20 r9_n;
			word20 r11_n;
			word20 r8_n;
			sr_n = vPortYield(pc, sr_n, out r8_n, out r9_n, out r10_n, out r11_n);
		}
	}
	else
	{
		word20 r15_n;
		sr_n = xTaskResumeAll(pc, sr_n, out r15_n);
	}
	r15Out = r10_n;
	return sr_n;
}

// 4FF6: Register Eq_n xQueueReceiveFromISR(Register ui20 sr, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15)
Eq_n xQueueReceiveFromISR(ui20 sr, Eq_n r13, Eq_n r14, Eq_n r15)
{
	Eq_n r15_n;
	word16 v9_n = *((word24) r15 + 0x0028);
	if (v9_n != 0x00)
	{
		Eq_n v12_n = *((word24) r15 + 44);
		word20 r15_n = Mem8[r15 + 0x06:word16] + v12_n;
		*((word24) r15 + 0x06) = r15_n;
		if (r15_n < *((word24) r15 + 0x02))
			*((word24) r15 + 0x06) = *r15;
		*((word24) r15 + 0x0028) = v9_n + ~0x00;
		memcpy(sr, v12_n, *((word24) r15 + 0x06), r14);
		word16 v23_n = *((word24) r15 + 0x002E);
		if (v23_n != ~0x00)
			*((word24) r15 + 0x002E) = v23_n + 0x01;
		else if (*r13 == 0x00 && (*((word24) r15 + 0x08) != 0x00 && xTaskRemoveFromEventList((word24) r15 + 0x08) != 0x00))
			r13->u0 = 0x01;
		r15_n.u0 = 0x01;
	}
	else
		r15_n.u0 = 0x00;
	return r15_n;
}

// 5068: void uxQueueMessagesWaiting()
void uxQueueMessagesWaiting()
{
	++globals->ptr0218;
	if (globals->ptr0218 != 0x00)
	{
		globals->ptr0218 += ~0x00;
		globals->ptr0218 != 0x00;
	}
}

// 507E: void vQueueDelete()
void vQueueDelete()
{
	vPortFree();
	vPortFree();
}

// 5092: Register ui20 prvUnlockQueue(Register ui20 sr, Register Eq_n r15, Register out Eq_n r15Out)
ui20 prvUnlockQueue(ui20 sr, Eq_n r15, union Eq_n & r15Out)
{
	++globals->ptr0218;
	ci16 v8_n = *((word24) r15 + 0x0030);
	*((word24) r15 + 0x0030) = v8_n + ~0x00;
	Eq_n r10_n = 0x00;
	ui20 sr_n = sr & ~0x08;
	if (v8_n >= ~0x00)
	{
		*((word24) r15 + 0x0030) = ~0x00;
		if (*((word24) r15 + 0x0018) != 0x00 && xTaskRemoveFromEventList((word24) r15 + 0x0018) != 0x00)
			r10_n.u0 = 0x01;
	}
	if (0x0218 != 0x00)
	{
		globals->ptr0218 += ~0x00;
		if (globals->ptr0218 == 0x00)
			sr_n |= 0x08;
	}
	++globals->ptr0218;
	ci16 v13_n = *((word24) r15 + 0x002E);
	*((word24) r15 + 0x002E) = v13_n + ~0x00;
	ui20 sr_n = sr_n & ~0x08;
	if (v13_n >= ~0x00)
	{
		*((word24) r15 + 0x002E) = ~0x00;
		if (*((word24) r15 + 0x08) != 0x00 && xTaskRemoveFromEventList((word24) r15 + 0x08) != 0x00)
			r10_n.u0 = 0x01;
	}
	if (0x0218 != 0x00)
	{
		globals->ptr0218 += ~0x00;
		if (globals->ptr0218 == 0x00)
			sr_n |= 0x08;
	}
	r15Out = r10_n;
	return sr_n;
}

// 510C: Register ui20 prvIsQueueEmpty(Register ui20 sr, Register Eq_n r15, Register out Eq_n r15Out)
ui20 prvIsQueueEmpty(ui20 sr, Eq_n r15, union Eq_n & r15Out)
{
	++globals->ptr0218;
	ui20 sr_n = sr & ~0x08;
	Eq_n r14_n = 0x00;
	if (*((word24) r15 + 0x0028) == 0x00)
		r14_n.u0 = 0x01;
	if (0x0218 != 0x00)
	{
		globals->ptr0218 += ~0x00;
		if (globals->ptr0218 == 0x00)
			sr_n |= 0x08;
	}
	r15Out = r14_n;
	return sr_n;
}

// 512E: Register ui20 prvIsQueueFull(Register ui20 sr, Register Eq_n r15, Register out Eq_n r15Out)
ui20 prvIsQueueFull(ui20 sr, Eq_n r15, union Eq_n & r15Out)
{
	++globals->ptr0218;
	ui20 sr_n = sr & ~0x08;
	Eq_n r14_n = 0x00;
	if (*((word24) r15 + 0x0028) == *((word24) r15 + 0x002A))
		r14_n.u0 = 0x01;
	if (0x0218 != 0x00)
	{
		globals->ptr0218 += ~0x00;
		if (globals->ptr0218 == 0x00)
			sr_n |= 0x08;
	}
	r15Out = r14_n;
	return sr_n;
}

// 5156: Register ui20 pvPortMalloc(Register (ptr20 Eq_n) pc, Register ui20 sr, Register Eq_n r15, Register out Eq_n r15Out)
ui20 pvPortMalloc(struct Eq_n * pc, ui20 sr, Eq_n r15, union Eq_n & r15Out)
{
	Eq_n r11_n = r15;
	Eq_n r10_n = 0x00;
	if ((r15 & 0x01) != 0x00)
		r11_n = r15 - (r15 & 0x01) + 0x02;
	Eq_n r14_n = 0x0216;
	ui20 sr_n = vTaskSuspendAll(sr);
	word20 r15_n = r14_n + r11_n;
	if (r15_n >= 0x0708 && r14_n >= r15_n)
	{
		globals->t0216 = r15_n;
		r10_n = (word24) r14_n + 0x02AA;
	}
	word20 r15_n;
	ui20 sr_n = xTaskResumeAll(pc, sr_n, out r15_n);
	r15Out = r10_n;
	return sr_n;
}

// 5192: void vPortFree()
void vPortFree()
{
}

// 5194: void vPortInitialiseBlocks()
void vPortInitialiseBlocks()
{
	globals->t0216.u0 = 0x00;
}

// 519A: Register (ptr20 Eq_n) pxPortInitialiseStack(Register Eq_n r13, Register Eq_n r14, Register (ptr20 Eq_n) r15)
union Eq_n * pxPortInitialiseStack(Eq_n r13, Eq_n r14, union Eq_n * r15)
{
	*r15 = (union Eq_n *) r14;
	*(r15 - 0x02) = 0x08;
	*(r15 - 0x04) = 0x4444;
	*(r15 - 0x06) = 0x5555;
	*(r15 - 0x08) = 0x6666;
	*(r15 - 0x0A) = 0x7777;
	*(r15 - 0x0C) = 0x8888;
	*(r15 - 0x0E) = 0x9999;
	*(r15 - 0x10) = 0xAAAA;
	*(r15 - 0x12) = ~0x4444;
	*(r15 - 0x14) = 0xCCCC;
	*(r15 - 22) = ~0x2222;
	*(r15 - 0x18) = ~0x1111;
	*(r15 - 0x1A) = (union Eq_n *) r13;
	*(r15 - 0x1C) = 0x00;
	return r15 - 0x1C;
}

// 520A: void xPortStartScheduler(Register (ptr20 Eq_n) pc)
void xPortStartScheduler(struct Eq_n * pc)
{
	prvSetupTimerInterrupt();
	pc->wFFFFB000 = **pc->ptrFFFFAFF2;
}

// 5238: void vPortEndScheduler()
void vPortEndScheduler()
{
}

// 523A: Register ui20 vPortYield(Register (ptr20 Eq_n) pc, Register ui20 sr, Register out Eq_n r8Out, Register out Eq_n r9Out, Register out Eq_n r10Out, Register out Eq_n r11Out)
ui20 vPortYield(struct Eq_n * pc, ui20 sr, union Eq_n & r8Out, union Eq_n & r9Out, union Eq_n & r10Out, union Eq_n & r11Out)
{
	*pc->ptrFFFFAFA4 = fp - 0x001C;
	vTaskSwitchContext();
	struct Eq_n * v21_n = *pc->ptrFFFFAF98;
	pc->wFFFFAFA6 = v21_n->w0000;
	Eq_n r11_n = v21_n->t000A;
	Eq_n r10_n = v21_n->t000C;
	Eq_n r9_n = v21_n->t000E;
	r8Out = v21_n->t0010;
	r9Out = r9_n;
	r10Out = r10_n;
	r11Out = r11_n;
	return sr & ~0x08;
}

// 528E: void prvSetupTimerInterrupt()
void prvSetupTimerInterrupt()
{
	((union Eq_n *) 0x0160)->u0 = 0x00;
	((union Eq_n *) 0x0160)->u0 = 0x0100;
	*(union Eq_n *) 0x0160 |= 0x04;
	*(ptr16 *) 0x0172 = 0x20;
	*(ptr16 *) 0x0162 = 0x10;
	*(union Eq_n *) 0x0160 |= 0x04;
	*(union Eq_n *) 0x0160 |= 0x10;
}

// 52B4: void prvTickISR(Register (ptr20 Eq_n) pc)
void prvTickISR(struct Eq_n * pc)
{
	*pc->ptrFFFFAF2E = fp - 0x001A;
	vTaskIncrementTick();
	vTaskSwitchContext();
	pc->wFFFFAF2C = **pc->ptrFFFFAF1E;
}

// 5308: void printf(Register Eq_n r8)
void printf(Eq_n r8)
{
	vuprintf(r8, (char *) &fp->t0002 + 0x02, fp->t0002, 17314);
}

// 531A: Register Eq_n PRINT(Register Eq_n r14)
Eq_n PRINT(Eq_n r14)
{
	if (r14 != 0x00)
		__write_char();
	else
	{
		Eq_n r15_n = 0x01;
		return r15_n;
	}
}

// 534A: void __write_pad(Register Eq_n r14)
void __write_pad(Eq_n r14)
{
	if (r14 < 0x01)
		return;
	__write_char();
}

// 537E: void vuprintf(Register Eq_n r8, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15)
void vuprintf(Eq_n r8, Eq_n r13, Eq_n r14, Eq_n r15)
{
	globals->ptr021A = 0x00;
	globals->t09B2 = r15;
	Eq_n r5_n = r13;
	Eq_n wLoc1C_n = 0x00;
	Eq_n wLoc1A_n = 0x00;
	Eq_n r6_n = r14;
l53A6:
	Eq_n r6_n;
	Eq_n v17_n = *r6_n;
	Eq_n r7_n = v17_n;
	r6_n = r6_n;
	if (v17_n != 0x00)
	{
		r6_n = r6_n;
		r6_n = r6_n;
		if (v17_n != 0x25)
		{
			do
			{
				r6_n = (word20) r6_n + 0x01;
				Eq_n v19_n = *r6_n;
				r7_n = v19_n;
			} while (v19_n != 0x00 && v19_n != 0x25);
		}
	}
	Eq_n r13_n = r6_n - r6_n;
	if (r13_n != 0x00 && PRINT(r13_n) < 0x00 || r7_n == 0x00)
		return;
	r6_n = r6_n + 0x01;
	byte bLoc1E_n = 0x00;
	Eq_n bLoc17_n = 0x00;
	Eq_n bLoc1D_n = 0x00;
	Eq_n r11_n = ~0x00;
	Eq_n bLoc24_n = 0x00;
	while (true)
	{
l53E8:
		Eq_n r7_n = *r6_n;
		++r6_n;
		while (true)
		{
			if (r7_n == 117 || (r7_n | 0x20) == 0x78)
			{
				if ((bLoc1E_n & 0x01) != 0x00)
				{
					r5_n += 0x04;
					wLoc1C_n = *r5_n;
					wLoc1A_n = *((word24) r5_n + 0x02);
				}
				else
				{
					r5_n = (word24) r5_n + 0x02;
					wLoc1C_n = *r5_n;
					wLoc1A_n.u0 = 0x00;
				}
			}
			if (r7_n == 0x20)
				break;
			if (r7_n == 0x23)
			{
				bLoc1E_n |= 0x08;
				goto l53E8;
			}
			if (r7_n == 0x2A)
			{
				Eq_n v49_n = *r5_n;
				r5_n += 0x02;
				bLoc1D_n = v49_n;
				if (v49_n >= 0x00)
					goto l53E8;
				bLoc1D_n = (v49_n ^ ~0x00) + 0x01;
l58A8:
				bLoc1E_n = (bLoc1E_n | 0x10) & ~0x20;
				goto l53E8;
			}
			if (r7_n == 0x2D)
				goto l58A8;
			if (r7_n == 0x2B)
			{
				bLoc24_n.u2 = 0x2B;
				goto l53E8;
			}
			if (r7_n != 0x2E)
			{
				if (r7_n == 0x30)
				{
					if ((bLoc1E_n & 0x10) == 0x00)
						bLoc1E_n |= 0x20;
					goto l53E8;
				}
				if (r7_n >= ~0x39)
				{
					Eq_n r13_n = 0x00;
					do
					{
						ui20 r14_n = r13_n * 0x02;
						ui20 r13_n = r13_n * 0x04 + r14_n + r14_n + r14_n + (int16) ((byte) r7_n);
						Eq_n v65_n = *r6_n;
						r13_n = r13_n + ~0x2F;
						r7_n = v65_n;
						++r6_n;
					} while (v65_n >= ~0x39);
					bLoc1D_n = r13_n + ~0x2F;
					continue;
				}
				if (r7_n == 0x68)
				{
					bLoc1E_n |= 0x04;
					goto l53E8;
				}
				if (r7_n == 0x6C)
				{
					bLoc1E_n |= 0x01;
					goto l53E8;
				}
				Eq_n r9_n;
				if (r7_n == 99)
				{
					r5_n += 0x02;
					goto l54F6;
				}
				Eq_n bLoc18_n;
				if (r7_n == 0x44)
				{
					bLoc1E_n |= 0x01;
l57AE:
					if ((bLoc1E_n & 0x01) != 0x00)
					{
						r5_n += 0x04;
						wLoc1C_n = *r5_n;
						wLoc1A_n = *((word24) r5_n + 0x02);
					}
					else
					{
						Eq_n v186_n = *r5_n;
						r5_n += 0x02;
						wLoc1C_n = v186_n;
						wLoc1A_n = 0x00 - (v186_n * 0x02 < 0x00) ^ ~0x00;
					}
					if (wLoc1A_n < 0x00)
					{
						Eq_n wLoc1C_n = wLoc1C_n ^ ~0x00;
						wLoc1C_n = (word24) wLoc1C_n + 0x01;
						wLoc1A_n = (wLoc1A_n ^ ~0x00) + (wLoc1C_n < 0x01);
						bLoc24_n.u2 = 0x2D;
					}
					bLoc18_n.u1 = 0x0A;
					goto l5620;
				}
				if (r7_n == 100 || r7_n == 0x69)
					goto l57AE;
				if (r7_n == 0x4F)
				{
					bLoc1E_n |= 0x01;
l57A2:
					bLoc18_n.u0 = 0x08;
					goto l561C;
				}
				if (r7_n == 111)
					goto l57A2;
				if (r7_n == 0x70)
				{
					r5_n += 0x02;
					wLoc1C_n = *r5_n;
					wLoc1A_n.u0 = 0x00;
					bLoc18_n.u1 = 0x10;
					bLoc1E_n |= 0x40;
					r7_n.u0 = 0x78;
					goto l561C;
				}
				if (r7_n != 115)
				{
					if (r7_n == 0x55)
					{
						bLoc1E_n |= 0x01;
l56FE:
						bLoc18_n.u1 = 0x0A;
						goto l561C;
					}
					if (r7_n == 117)
						goto l56FE;
					if (r7_n != 88 && r7_n != 0x78)
					{
						if (r7_n == 0x00)
							return;
l54F6:
						r9_n.u1 = 0x01;
						goto l54F8;
					}
					bLoc18_n.u1 = 0x10;
					if ((bLoc1E_n & 0x08) != 0x00 && (wLoc1C_n != 0x00 || wLoc1A_n != 0x00))
						bLoc1E_n |= 0x40;
l561C:
					bLoc24_n.u0 = 0x00;
l5620:
					bLoc17_n = r11_n;
					if (r11_n >= 0x00)
						bLoc1E_n &= ~0x20;
					struct Eq_n * wLoc20_n = fp - 0x24;
					if (wLoc1C_n == 0x00)
					{
						wLoc20_n = (word16) (fp - 0x24);
						if (wLoc1A_n != 0x00)
							goto l564A;
						wLoc20_n = (word16) (fp - 0x24);
						if (r11_n != 0x00)
							goto l564A;
					}
					else
					{
l564A:
						Eq_n wLoc14_n = (uint16) (uint8) bLoc18_n;
						do
						{
							byte bLoc16_n = 0x00;
							if (wLoc1A_n - (wLoc1C_n - wLoc14_n < 0x00) < 0x00)
								bLoc16_n = 0x01;
							Eq_n r4_n;
							Eq_n r14_n;
							Eq_n r8_n;
							word20 r12_n;
							word20 r13_n;
							word20 r15_n;
							fn00005B4E(r8, wLoc14_n, 0x00, wLoc1C_n, wLoc1A_n, out r8_n, out r12_n, out r13_n, out r14_n, out r15_n);
							if (r14_n >= 0x0A)
								r4_n = (word24) r14_n + 0x0030;
							else
							{
								r4_n = (word24) r14_n + 0x0057;
								if (r7_n == 88)
									r4_n = (word24) r14_n + 0x0057 & ~0x20;
							}
							wLoc20_n = wLoc20_n + 0x0000FFFF;
							wLoc20_n->b0000 = (byte) r4_n;
							word20 r14_n;
							Eq_n r12_n;
							Eq_n r13_n;
							word20 r15_n;
							fn00005B4E(r8_n, wLoc14_n, 0x00, wLoc1C_n, wLoc1A_n, out r8, out r12_n, out r13_n, out r14_n, out r15_n);
							wLoc1C_n = r12_n;
							wLoc1A_n = r13_n;
							wLoc20_n = wLoc20_n;
						} while (bLoc16_n != 0x00);
						if (bLoc18_n == 0x08 && ((bLoc1E_n & 0x08) != 0x00 && r4_n != 0x30))
						{
							wLoc20_n[0x0000FFFE] = (struct Eq_n) 0x30;
							wLoc20_n = wLoc20_n + 0x0000FFFE;
						}
					}
					r9_n = fp - 0x4C - (byte) wLoc20_n + 0x28;
					goto l54FC;
				}
				Eq_n v149_n = *r5_n;
				r5_n += 0x02;
				Eq_n wLoc20_n = v149_n;
				if (v149_n == 0x00)
					wLoc20_n = fp - 0x4C;
				Eq_n bLoc20_n = (byte) wLoc20_n;
				if (r11_n < 0x00)
				{
					Eq_n r15_n = wLoc20_n - 0x01;
					do
						++r15_n;
					while (*r15_n != 0x00);
					r9_n = r15_n - bLoc20_n;
					goto l54F8;
				}
				word20 r15_n = memchr((int16) (byte) r11_n, 0x00, wLoc20_n);
				if (r15_n != 0x00)
				{
					r9_n = r15_n - bLoc20_n;
					if (r11_n < r9_n)
						goto l573C;
				}
				else
				{
l573C:
					r9_n = r11_n;
				}
l54F8:
				bLoc24_n.u0 = 0x00;
l54FC:
				Eq_n r11_n = r9_n;
				Eq_n r10_n = bLoc17_n - r9_n;
				if (r10_n < 0x00)
					r10_n.u0 = 0x00;
				if (bLoc24_n != 0x00)
					r11_n.u1 = (byte) r9_n.u1 + 0x01;
				else if ((bLoc1E_n & 0x40) != 0x00)
					r11_n.u1 = (byte) r9_n.u1 + 0x02;
				word20 r11_n = r11_n + r10_n;
				r8 = bLoc1E_n & 0x30;
				if ((bLoc1E_n & 0x30) == 0x00)
				{
					Eq_n r13_n = (int16) (bLoc1D_n - (byte) r11_n);
					if (r13_n >= 0x01)
					{
						__write_pad(r13_n);
						if (false)
							return;
					}
				}
				Eq_n r14_n;
				if (bLoc24_n == 0x00)
				{
					if ((bLoc1E_n & 0x40) == 0x00)
						goto l5576;
					r14_n.u0 = 0x02;
				}
				else
					r14_n.u0 = 0x01;
				if (PRINT(r14_n) < 0x00)
					return;
l5576:
				if ((bLoc1E_n & 0x30) == 0x20)
				{
					Eq_n r13_n = (int16) (bLoc1D_n - (byte) r11_n);
					if (r13_n >= 0x01)
					{
						__write_pad(r13_n);
						if (false)
							return;
					}
				}
				__write_pad(r10_n);
				if (false || PRINT((int16) ((byte) r9_n)) < 0x00)
					return;
				if ((bLoc1E_n & 0x10) == 0x00)
					goto l53A6;
				Eq_n r13_n = (int16) (bLoc1D_n - (byte) r11_n);
				if (r13_n < 0x01)
					goto l53A6;
				__write_pad(r13_n);
				if (false)
					return;
				goto l53A6;
			}
			Eq_n v58_n = *r6_n;
			r7_n = v58_n;
			++r6_n;
			if (v58_n == 0x2A)
			{
				Eq_n v61_n = *r5_n;
				r5_n += 0x02;
				Eq_n r15_n = v61_n;
				if (v61_n < ~0x00)
					r15_n.u0 = ~0x00;
				r11_n = r15_n;
				goto l53E8;
			}
			Eq_n r13_n = 0x00;
			if (v58_n >= ~0x39)
			{
				do
				{
					ui20 r14_n = r13_n * 0x02;
					Eq_n v60_n = *r6_n;
					r13_n = r13_n * 0x04 + r14_n + r14_n + r14_n + (int16) ((byte) r7_n) + ~0x2F;
					r7_n = v60_n;
					++r6_n;
				} while (v60_n >= ~0x39);
			}
			Eq_n r15_n = r13_n;
			if (r13_n < ~0x00)
				r15_n.u0 = ~0x00;
			r11_n = r15_n;
		}
		if (bLoc24_n == 0x00)
			bLoc24_n.u2 = 0x20;
	}
}

// 593E: Register Eq_n memchr(Register Eq_n r13, Register Eq_n r14, Register Eq_n r15)
Eq_n memchr(Eq_n r13, Eq_n r14, Eq_n r15)
{
	Eq_n r15_n;
	if (r13 != 0x00)
	{
		Eq_n r14_n = r15;
		do
		{
			r14_n = (word24) r14_n + 0x01;
			if (*r14_n == r14)
			{
				r15_n = (word24) r14_n + 0x0000FFFF;
				return r15_n;
			}
			r13.u1 = (word20) r13.u1 + 0x0000FFFF;
		} while (r13 != 0x00);
	}
	r15_n.u0 = 0x00;
	return r15_n;
}

// 5962: void strncpy(Register Eq_n r13, Register Eq_n r14, Register (ptr24 byte) r15)
void strncpy(Eq_n r13, Eq_n r14, byte * r15)
{
	if (r13 != 0x00)
	{
		byte * r12_n = r15;
		do
		{
			*r12_n = (byte) *r14;
			++r14;
			++r12_n;
			if (*r12_n == 0x00)
			{
				word20 r13_n;
				for (r13_n = (word20) r13.u0 + 0x0000FFFF; r13_n != 0x00; r13_n += ~0x00)
				{
					*r12_n = 0x00;
					++r12_n;
				}
				return;
			}
			r13.u0 = (word20) r13.u0 + 0x0000FFFF;
		} while (r13 != 0x00);
	}
}

// 5994: Register ui20 memcpy(Register ui20 sr, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15)
ui20 memcpy(ui20 sr, Eq_n r13, Eq_n r14, Eq_n r15)
{
	Eq_n r11_n = r13;
	Eq_n r13_n = r15;
	Eq_n r12_n = r14;
	if (r13 != 0x00 && r15 != r14)
	{
		if (r15 >= r14)
		{
			ui20 r15_n = r14 | r15;
			bool C_n = (bool) cond(r15_n & 0x01);
			if ((r15_n & 0x01) != 0x00)
			{
				Eq_n r14_n;
				if (((r14 ^ r15) & 0x01) == 0x00 && r13 < 0x02)
					r14_n = 0x02 - (r14 & 0x01);
				else
					r14_n = r13;
				r11_n = r13 - r14_n;
				do
				{
					*r13_n = *r12_n;
					r14_n = (word24) r14_n + 0x0000FFFF;
					++r12_n;
					++r13_n;
					C_n = (bool) cond(r14_n);
				} while (r14_n != 0x00);
			}
			sr &= ~0x01;
			Eq_n r14_n = __rcr(r11_n, 0x01, C_n);
			while (r14_n != 0x00)
			{
				*r13_n = *r12_n;
				r12_n += 0x02;
				r13_n += 0x02;
				r14_n = (word24) r14_n + 0x0000FFFF;
			}
			ui20 r14_n;
			for (r14_n = r11_n & 0x01; r14_n != 0x00; r14_n += ~0x00)
			{
				*r13_n = *r12_n;
				++r12_n;
				++r13_n;
			}
		}
		else
		{
			word20 r12_n = r14 + r13;
			word20 r13_n = r15 + r13;
			ui20 r15_n = r12_n | r13_n;
			bool C_n = (bool) cond(r15_n & 0x01);
			if ((r15_n & 0x01) != 0x00)
			{
				Eq_n r14_n;
				if (((r12_n ^ r13_n) & 0x01) == 0x00 && r13 < 0x03)
					r14_n = r12_n & 0x01;
				else
					r14_n = r13;
				r11_n = r13 - r14_n;
				do
				{
					r12_n = (word20) r12_n + 0x0000FFFF;
					r13_n = (word20) r13_n + 0x0000FFFF;
					*r13_n = *r12_n;
					r14_n = (word24) r14_n + 0x0000FFFF;
					C_n = (bool) cond(r14_n);
				} while (r14_n != 0x00);
			}
			sr &= ~0x01;
			Eq_n r14_n = __rcr(r11_n, 0x01, C_n);
			while (r14_n != 0x00)
			{
				r12_n -= 0x02;
				r13_n -= 0x02;
				*r13_n = *r12_n;
				r14_n = (word24) r14_n + 0x0000FFFF;
			}
			ui20 r14_n;
			for (r14_n = r11_n & 0x01; r14_n != 0x00; r14_n += ~0x00)
			{
				r12_n += ~0x00;
				r13_n += ~0x00;
				*r13_n = *r12_n;
			}
		}
	}
	return sr;
}

// 5A68: Register ui20 memset(Register ui20 sr, Register Eq_n r13, Register Eq_n r14, Register Eq_n r15)
ui20 memset(ui20 sr, Eq_n r13, Eq_n r14, Eq_n r15)
{
	Eq_n r14_n = r15;
	if (r13 >= 0x06)
	{
		while (r13 != 0x00)
		{
			*r14_n = r14;
			++r14_n;
			r13 = (word24) r13 + 0x0000FFFF;
		}
	}
	else
	{
		Eq_n r11_n = r14;
		if (r14 != 0x00)
			r11_n = r14 | __swpb(r14);
		bool C_n = (bool) cond(r15 & 0x01);
		if ((r15 & 0x01) != 0x00)
		{
			Eq_n r15_n = 0x02 - (r15 & 0x01);
			Eq_n r12_n = r15_n;
			r13 -= r15_n;
			do
			{
				*r14_n = r14;
				r12_n = (word24) r12_n + 0x0000FFFF;
				++r14_n;
				C_n = (bool) cond(r12_n);
			} while (r12_n != 0x00);
		}
		sr &= ~0x01;
		Eq_n r12_n = __rcr(r13, 0x01, C_n);
		do
		{
			*r14_n = r11_n;
			r14_n += 0x02;
			r12_n = (word24) r12_n + 0x0000FFFF;
		} while (r12_n != 0x00);
		Eq_n r12_n = r13 & 0x01;
		while (r12_n != 0x00)
		{
			*r14_n = r14;
			++r14_n;
			r12_n = (word24) r12_n + 0x0000FFFF;
		}
	}
	return sr;
}

// 00005ADC: Register Eq_n fn00005ADC(Register Eq_n r10, Register Eq_n r11, Register Eq_n r12, Register Eq_n r13, Register out Eq_n r15Out)
Eq_n fn00005ADC(Eq_n r10, Eq_n r11, Eq_n r12, Eq_n r13, union Eq_n & r15Out)
{
	*(union Eq_n *) 0x0130 = r12;
	*(union Eq_n *) 0x0138 = r10;
	*(union Eq_n *) 0x0134 = r12;
	*(ptr16 *) 0x013A = 0x013C;
	*(union Eq_n *) 0x0138 = r11;
	*(union Eq_n *) 0x0134 = r13;
	*(union Eq_n *) 0x0138 = r10;
	r15Out.u0 = 0x013A;
	return 0x013A;
}

// 00005B04: Register Eq_n fn00005B04(Register Eq_n r10, Register Eq_n r11, Register Eq_n r12, Register Eq_n r13)
Eq_n fn00005B04(Eq_n r10, Eq_n r11, Eq_n r12, Eq_n r13)
{
	Eq_n r8_n = 0x00;
	if ((r13 & 0x8000) != 0x00)
	{
		r12 = (r12 ^ ~0x00) + 0x01;
		r13 = (r13 ^ ~0x00) + (r12 < 0x00);
		r8_n |= 0x04;
	}
	if ((r11 & 0x8000) != 0x00)
	{
		r10 = (r10 ^ ~0x00) + 0x01;
		r11 = (r11 ^ ~0x00) + (r10 < 0x00);
		r8_n |= 0x08;
	}
	word20 r13_n;
	word20 r14_n;
	word20 r15_n;
	Eq_n r8_n;
	Eq_n r12_n;
	Eq_n r8_n = __rcr(r8_n, 0x01, fn00005B4E(r8_n, r10, r11, r12, r13, out r8_n, out r12_n, out r13_n, out r14_n, out r15_n));
	if ((r8_n & 0x04) != 0x00)
		r12_n = (r12_n ^ ~0x00) + 0x01;
	if ((r8_n & 0x08) != 0x00)
		r12_n = (r12_n ^ ~0x00) + 0x01;
	return r12_n;
}

// 00005B4E: FlagGroup bool fn00005B4E(Register Eq_n r8, Register Eq_n r10, Register Eq_n r11, Register Eq_n r12, Register Eq_n r13, Register out Eq_n r8Out, Register out Eq_n r12Out, Register out Eq_n r13Out, Register out Eq_n r14Out, Register out Eq_n r15Out)
bool fn00005B4E(Eq_n r8, Eq_n r10, Eq_n r11, Eq_n r12, Eq_n r13, union Eq_n & r8Out, union Eq_n & r12Out, union Eq_n & r13Out, union Eq_n & r14Out, union Eq_n & r15Out)
{
	Eq_n r15_n = 0x00;
	Eq_n r14_n = 0x00;
	Eq_n r9_n = 33;
	while (true)
	{
		r12 *= 0x02;
		r13 = r13 * 0x02 + (r12 < 0x00);
		--r9_n;
		Eq_n r8_n = r8 * 0x02 + (r13 < 0x00);
		bool C_n = (bool) cond(r9_n);
		if (r9_n == 0x00)
			break;
		r8 = __rcr(r8_n, 0x01, C_n);
		r14_n = r14_n * 0x02 + (r8 < 0x00);
		r15_n = r15_n * 0x02 + (r14_n < 0x00);
		if (r15_n < r11 && (r15_n != r11 || r14_n < r10))
		{
			r14_n -= r10;
			r15_n = r15_n - r11 - (r14_n < 0x00);
		}
	}
	r8Out = r8_n;
	r12Out = r12;
	r13Out = r13;
	r14Out = r14_n;
	r15Out = r15_n;
	return C_n;
}

